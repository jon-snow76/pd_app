{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.offlineService = exports.default = void 0;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _netinfo = _interopRequireDefault(require(\"@react-native-community/netinfo\"));\nvar _asyncStorage = _interopRequireDefault(require(\"@react-native-async-storage/async-storage\"));\nvar OfflineService = function () {\n  function OfflineService() {\n    (0, _classCallCheck2.default)(this, OfflineService);\n    this.isOnline = true;\n    this.listeners = [];\n    this.syncQueue = [];\n    this.isInitialized = false;\n  }\n  return (0, _createClass2.default)(OfflineService, [{\n    key: \"initialize\",\n    value: (function () {\n      var _initialize = (0, _asyncToGenerator2.default)(function* () {\n        var _this = this,\n          _initialState$isConne;\n        if (this.isInitialized) return;\n        yield this.loadSyncQueue();\n        _netinfo.default.addEventListener(function (state) {\n          var _state$isConnected;\n          var wasOnline = _this.isOnline;\n          _this.isOnline = (_state$isConnected = state.isConnected) != null ? _state$isConnected : false;\n          _this.notifyListeners();\n          if (!wasOnline && _this.isOnline) {\n            _this.processSyncQueue();\n          }\n        });\n        var initialState = yield _netinfo.default.fetch();\n        this.isOnline = (_initialState$isConne = initialState.isConnected) != null ? _initialState$isConne : false;\n        this.isInitialized = true;\n      });\n      function initialize() {\n        return _initialize.apply(this, arguments);\n      }\n      return initialize;\n    }())\n  }, {\n    key: \"getIsOnline\",\n    value: function getIsOnline() {\n      return this.isOnline;\n    }\n  }, {\n    key: \"addConnectionListener\",\n    value: function addConnectionListener(listener) {\n      var _this2 = this;\n      this.listeners.push(listener);\n      return function () {\n        var index = _this2.listeners.indexOf(listener);\n        if (index > -1) {\n          _this2.listeners.splice(index, 1);\n        }\n      };\n    }\n  }, {\n    key: \"queueOperation\",\n    value: (function () {\n      var _queueOperation = (0, _asyncToGenerator2.default)(function* (operation) {\n        this.syncQueue.push(Object.assign({}, operation, {\n          timestamp: Date.now(),\n          id: this.generateOperationId()\n        }));\n        yield this.saveSyncQueue();\n      });\n      function queueOperation(_x) {\n        return _queueOperation.apply(this, arguments);\n      }\n      return queueOperation;\n    }())\n  }, {\n    key: \"processSyncQueue\",\n    value: (function () {\n      var _processSyncQueue = (0, _asyncToGenerator2.default)(function* () {\n        if (!this.isOnline || this.syncQueue.length === 0) {\n          return;\n        }\n        console.log(`Processing ${this.syncQueue.length} queued operations`);\n        var operations = (0, _toConsumableArray2.default)(this.syncQueue);\n        this.syncQueue = [];\n        for (var operation of operations) {\n          try {\n            yield this.executeOperation(operation);\n            console.log(`Successfully processed operation: ${operation.type}`);\n          } catch (error) {\n            console.error(`Failed to process operation: ${operation.type}`, error);\n            this.syncQueue.push(operation);\n          }\n        }\n        yield this.saveSyncQueue();\n      });\n      function processSyncQueue() {\n        return _processSyncQueue.apply(this, arguments);\n      }\n      return processSyncQueue;\n    }())\n  }, {\n    key: \"getSyncQueue\",\n    value: function getSyncQueue() {\n      return (0, _toConsumableArray2.default)(this.syncQueue);\n    }\n  }, {\n    key: \"clearSyncQueue\",\n    value: (function () {\n      var _clearSyncQueue = (0, _asyncToGenerator2.default)(function* () {\n        this.syncQueue = [];\n        yield this.saveSyncQueue();\n      });\n      function clearSyncQueue() {\n        return _clearSyncQueue.apply(this, arguments);\n      }\n      return clearSyncQueue;\n    }())\n  }, {\n    key: \"createBackup\",\n    value: (function () {\n      var _createBackup = (0, _asyncToGenerator2.default)(function* () {\n        var backup = {\n          timestamp: Date.now(),\n          version: '1.0.0',\n          data: {\n            timetableEvents: yield this.getStorageData('@timetable_events'),\n            tasks: yield this.getStorageData('@tasks'),\n            medications: yield this.getStorageData('@medications'),\n            userPreferences: yield this.getStorageData('@user_preferences'),\n            productivityLogs: yield this.getStorageData('@productivity_logs')\n          }\n        };\n        yield _asyncStorage.default.setItem('@app_backup', JSON.stringify(backup));\n        return backup;\n      });\n      function createBackup() {\n        return _createBackup.apply(this, arguments);\n      }\n      return createBackup;\n    }())\n  }, {\n    key: \"restoreFromBackup\",\n    value: (function () {\n      var _restoreFromBackup = (0, _asyncToGenerator2.default)(function* (backup) {\n        try {\n          for (var _ref of Object.entries(backup.data)) {\n            var _ref2 = (0, _slicedToArray2.default)(_ref, 2);\n            var key = _ref2[0];\n            var data = _ref2[1];\n            if (data) {\n              var storageKey = this.getStorageKeyFromDataType(key);\n              yield _asyncStorage.default.setItem(storageKey, JSON.stringify(data));\n            }\n          }\n          console.log('Successfully restored from backup');\n        } catch (error) {\n          console.error('Failed to restore from backup:', error);\n          throw error;\n        }\n      });\n      function restoreFromBackup(_x2) {\n        return _restoreFromBackup.apply(this, arguments);\n      }\n      return restoreFromBackup;\n    }())\n  }, {\n    key: \"getLatestBackup\",\n    value: (function () {\n      var _getLatestBackup = (0, _asyncToGenerator2.default)(function* () {\n        try {\n          var backupData = yield _asyncStorage.default.getItem('@app_backup');\n          return backupData ? JSON.parse(backupData) : null;\n        } catch (error) {\n          console.error('Failed to get backup:', error);\n          return null;\n        }\n      });\n      function getLatestBackup() {\n        return _getLatestBackup.apply(this, arguments);\n      }\n      return getLatestBackup;\n    }())\n  }, {\n    key: \"notifyListeners\",\n    value: function notifyListeners() {\n      var _this3 = this;\n      this.listeners.forEach(function (listener) {\n        return listener(_this3.isOnline);\n      });\n    }\n  }, {\n    key: \"loadSyncQueue\",\n    value: function () {\n      var _loadSyncQueue = (0, _asyncToGenerator2.default)(function* () {\n        try {\n          var queueData = yield _asyncStorage.default.getItem('@sync_queue');\n          this.syncQueue = queueData ? JSON.parse(queueData) : [];\n        } catch (error) {\n          console.error('Failed to load sync queue:', error);\n          this.syncQueue = [];\n        }\n      });\n      function loadSyncQueue() {\n        return _loadSyncQueue.apply(this, arguments);\n      }\n      return loadSyncQueue;\n    }()\n  }, {\n    key: \"saveSyncQueue\",\n    value: function () {\n      var _saveSyncQueue = (0, _asyncToGenerator2.default)(function* () {\n        try {\n          yield _asyncStorage.default.setItem('@sync_queue', JSON.stringify(this.syncQueue));\n        } catch (error) {\n          console.error('Failed to save sync queue:', error);\n        }\n      });\n      function saveSyncQueue() {\n        return _saveSyncQueue.apply(this, arguments);\n      }\n      return saveSyncQueue;\n    }()\n  }, {\n    key: \"generateOperationId\",\n    value: function generateOperationId() {\n      return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n  }, {\n    key: \"executeOperation\",\n    value: function () {\n      var _executeOperation = (0, _asyncToGenerator2.default)(function* (operation) {\n        switch (operation.type) {\n          case 'CREATE_EVENT':\n          case 'UPDATE_EVENT':\n          case 'DELETE_EVENT':\n            yield this.simulateApiCall(operation);\n            break;\n          case 'CREATE_TASK':\n          case 'UPDATE_TASK':\n          case 'DELETE_TASK':\n            yield this.simulateApiCall(operation);\n            break;\n          case 'UPDATE_MEDICATION':\n            yield this.simulateApiCall(operation);\n            break;\n          default:\n            console.warn(`Unknown operation type: ${operation.type}`);\n        }\n      });\n      function executeOperation(_x3) {\n        return _executeOperation.apply(this, arguments);\n      }\n      return executeOperation;\n    }()\n  }, {\n    key: \"simulateApiCall\",\n    value: function () {\n      var _simulateApiCall = (0, _asyncToGenerator2.default)(function* (operation) {\n        yield new Promise(function (resolve) {\n          return setTimeout(resolve, 100);\n        });\n        console.log(`Simulated API call for operation: ${operation.type}`);\n      });\n      function simulateApiCall(_x4) {\n        return _simulateApiCall.apply(this, arguments);\n      }\n      return simulateApiCall;\n    }()\n  }, {\n    key: \"getStorageData\",\n    value: function () {\n      var _getStorageData = (0, _asyncToGenerator2.default)(function* (key) {\n        try {\n          var data = yield _asyncStorage.default.getItem(key);\n          return data ? JSON.parse(data) : null;\n        } catch (error) {\n          console.error(`Failed to get storage data for key: ${key}`, error);\n          return null;\n        }\n      });\n      function getStorageData(_x5) {\n        return _getStorageData.apply(this, arguments);\n      }\n      return getStorageData;\n    }()\n  }, {\n    key: \"getStorageKeyFromDataType\",\n    value: function getStorageKeyFromDataType(dataType) {\n      var keyMap = {\n        timetableEvents: '@timetable_events',\n        tasks: '@tasks',\n        medications: '@medications',\n        userPreferences: '@user_preferences',\n        productivityLogs: '@productivity_logs'\n      };\n      return keyMap[dataType] || `@${dataType}`;\n    }\n  }]);\n}();\nvar offlineService = exports.offlineService = new OfflineService();\nvar _default = exports.default = OfflineService;","map":{"version":3,"names":["_netinfo","_interopRequireDefault","require","_asyncStorage","OfflineService","_classCallCheck2","default","isOnline","listeners","syncQueue","isInitialized","_createClass2","key","value","_initialize","_asyncToGenerator2","_this","_initialState$isConne","loadSyncQueue","NetInfo","addEventListener","state","_state$isConnected","wasOnline","isConnected","notifyListeners","processSyncQueue","initialState","fetch","initialize","apply","arguments","getIsOnline","addConnectionListener","listener","_this2","push","index","indexOf","splice","_queueOperation","operation","Object","assign","timestamp","Date","now","id","generateOperationId","saveSyncQueue","queueOperation","_x","_processSyncQueue","length","console","log","operations","_toConsumableArray2","executeOperation","type","error","getSyncQueue","_clearSyncQueue","clearSyncQueue","_createBackup","backup","version","data","timetableEvents","getStorageData","tasks","medications","userPreferences","productivityLogs","AsyncStorage","setItem","JSON","stringify","createBackup","_restoreFromBackup","_ref","entries","_ref2","_slicedToArray2","storageKey","getStorageKeyFromDataType","restoreFromBackup","_x2","_getLatestBackup","backupData","getItem","parse","getLatestBackup","_this3","forEach","_loadSyncQueue","queueData","_saveSyncQueue","Math","random","toString","substr","_executeOperation","simulateApiCall","warn","_x3","_simulateApiCall","Promise","resolve","setTimeout","_x4","_getStorageData","_x5","dataType","keyMap","offlineService","exports","_default"],"sources":["/Users/vaishnavkrishnan/Desktop/pd_app/src/services/OfflineService.ts"],"sourcesContent":["import NetInfo, { NetInfoState } from '@react-native-community/netinfo';\nimport AsyncStorage from '@react-native-async-storage/async-storage';\n\n/**\n * Service for handling offline functionality and data synchronization\n */\nclass OfflineService {\n  private isOnline: boolean = true;\n  private listeners: Array<(isOnline: boolean) => void> = [];\n  private syncQueue: Array<QueuedOperation> = [];\n  private isInitialized: boolean = false;\n\n  /**\n   * Initialize the offline service\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    // Load queued operations from storage\n    await this.loadSyncQueue();\n\n    // Set up network state listener\n    NetInfo.addEventListener((state: NetInfoState) => {\n      const wasOnline = this.isOnline;\n      this.isOnline = state.isConnected ?? false;\n\n      // Notify listeners of connection change\n      this.notifyListeners();\n\n      // If we just came back online, process sync queue\n      if (!wasOnline && this.isOnline) {\n        this.processSyncQueue();\n      }\n    });\n\n    // Get initial network state\n    const initialState = await NetInfo.fetch();\n    this.isOnline = initialState.isConnected ?? false;\n    \n    this.isInitialized = true;\n  }\n\n  /**\n   * Check if device is currently online\n   */\n  getIsOnline(): boolean {\n    return this.isOnline;\n  }\n\n  /**\n   * Add listener for connection state changes\n   */\n  addConnectionListener(listener: (isOnline: boolean) => void): () => void {\n    this.listeners.push(listener);\n    \n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(listener);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n\n  /**\n   * Queue an operation for when connection is restored\n   */\n  async queueOperation(operation: QueuedOperation): Promise<void> {\n    this.syncQueue.push({\n      ...operation,\n      timestamp: Date.now(),\n      id: this.generateOperationId(),\n    });\n\n    await this.saveSyncQueue();\n  }\n\n  /**\n   * Process all queued operations\n   */\n  async processSyncQueue(): Promise<void> {\n    if (!this.isOnline || this.syncQueue.length === 0) {\n      return;\n    }\n\n    console.log(`Processing ${this.syncQueue.length} queued operations`);\n\n    const operations = [...this.syncQueue];\n    this.syncQueue = [];\n\n    for (const operation of operations) {\n      try {\n        await this.executeOperation(operation);\n        console.log(`Successfully processed operation: ${operation.type}`);\n      } catch (error) {\n        console.error(`Failed to process operation: ${operation.type}`, error);\n        // Re-queue failed operations\n        this.syncQueue.push(operation);\n      }\n    }\n\n    await this.saveSyncQueue();\n  }\n\n  /**\n   * Get the current sync queue\n   */\n  getSyncQueue(): QueuedOperation[] {\n    return [...this.syncQueue];\n  }\n\n  /**\n   * Clear the sync queue\n   */\n  async clearSyncQueue(): Promise<void> {\n    this.syncQueue = [];\n    await this.saveSyncQueue();\n  }\n\n  /**\n   * Create a backup of all app data\n   */\n  async createBackup(): Promise<AppBackup> {\n    const backup: AppBackup = {\n      timestamp: Date.now(),\n      version: '1.0.0',\n      data: {\n        timetableEvents: await this.getStorageData('@timetable_events'),\n        tasks: await this.getStorageData('@tasks'),\n        medications: await this.getStorageData('@medications'),\n        userPreferences: await this.getStorageData('@user_preferences'),\n        productivityLogs: await this.getStorageData('@productivity_logs'),\n      },\n    };\n\n    // Save backup to storage\n    await AsyncStorage.setItem('@app_backup', JSON.stringify(backup));\n    \n    return backup;\n  }\n\n  /**\n   * Restore app data from backup\n   */\n  async restoreFromBackup(backup: AppBackup): Promise<void> {\n    try {\n      // Restore each data type\n      for (const [key, data] of Object.entries(backup.data)) {\n        if (data) {\n          const storageKey = this.getStorageKeyFromDataType(key);\n          await AsyncStorage.setItem(storageKey, JSON.stringify(data));\n        }\n      }\n\n      console.log('Successfully restored from backup');\n    } catch (error) {\n      console.error('Failed to restore from backup:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get the latest backup\n   */\n  async getLatestBackup(): Promise<AppBackup | null> {\n    try {\n      const backupData = await AsyncStorage.getItem('@app_backup');\n      return backupData ? JSON.parse(backupData) : null;\n    } catch (error) {\n      console.error('Failed to get backup:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Private methods\n   */\n  private notifyListeners(): void {\n    this.listeners.forEach(listener => listener(this.isOnline));\n  }\n\n  private async loadSyncQueue(): Promise<void> {\n    try {\n      const queueData = await AsyncStorage.getItem('@sync_queue');\n      this.syncQueue = queueData ? JSON.parse(queueData) : [];\n    } catch (error) {\n      console.error('Failed to load sync queue:', error);\n      this.syncQueue = [];\n    }\n  }\n\n  private async saveSyncQueue(): Promise<void> {\n    try {\n      await AsyncStorage.setItem('@sync_queue', JSON.stringify(this.syncQueue));\n    } catch (error) {\n      console.error('Failed to save sync queue:', error);\n    }\n  }\n\n  private generateOperationId(): string {\n    return `op_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  private async executeOperation(operation: QueuedOperation): Promise<void> {\n    // This would typically make API calls to sync data\n    // For now, we'll just simulate the operation\n    switch (operation.type) {\n      case 'CREATE_EVENT':\n      case 'UPDATE_EVENT':\n      case 'DELETE_EVENT':\n        // Simulate API call for timetable events\n        await this.simulateApiCall(operation);\n        break;\n      case 'CREATE_TASK':\n      case 'UPDATE_TASK':\n      case 'DELETE_TASK':\n        // Simulate API call for tasks\n        await this.simulateApiCall(operation);\n        break;\n      case 'UPDATE_MEDICATION':\n        // Simulate API call for medications\n        await this.simulateApiCall(operation);\n        break;\n      default:\n        console.warn(`Unknown operation type: ${operation.type}`);\n    }\n  }\n\n  private async simulateApiCall(operation: QueuedOperation): Promise<void> {\n    // Simulate network delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n    \n    // In a real app, this would make actual API calls\n    console.log(`Simulated API call for operation: ${operation.type}`);\n  }\n\n  private async getStorageData(key: string): Promise<any> {\n    try {\n      const data = await AsyncStorage.getItem(key);\n      return data ? JSON.parse(data) : null;\n    } catch (error) {\n      console.error(`Failed to get storage data for key: ${key}`, error);\n      return null;\n    }\n  }\n\n  private getStorageKeyFromDataType(dataType: string): string {\n    const keyMap: Record<string, string> = {\n      timetableEvents: '@timetable_events',\n      tasks: '@tasks',\n      medications: '@medications',\n      userPreferences: '@user_preferences',\n      productivityLogs: '@productivity_logs',\n    };\n    \n    return keyMap[dataType] || `@${dataType}`;\n  }\n}\n\n// Types\nexport interface QueuedOperation {\n  id?: string;\n  type: OperationType;\n  data: any;\n  timestamp?: number;\n  retryCount?: number;\n}\n\nexport type OperationType = \n  | 'CREATE_EVENT'\n  | 'UPDATE_EVENT'\n  | 'DELETE_EVENT'\n  | 'CREATE_TASK'\n  | 'UPDATE_TASK'\n  | 'DELETE_TASK'\n  | 'UPDATE_MEDICATION';\n\nexport interface AppBackup {\n  timestamp: number;\n  version: string;\n  data: {\n    timetableEvents: any;\n    tasks: any;\n    medications: any;\n    userPreferences: any;\n    productivityLogs: any;\n  };\n}\n\n// Export singleton instance\nexport const offlineService = new OfflineService();\nexport default OfflineService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}