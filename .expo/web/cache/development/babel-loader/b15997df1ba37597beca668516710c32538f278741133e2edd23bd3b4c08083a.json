{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.suggestOptimalTime = exports.getTotalScheduledTime = exports.getNextRecurrence = exports.getEventsInRange = exports.getEventsForDate = exports.getEventEndTime = exports.getAvailableTimeSlots = exports.generateRecurringEvents = exports.findConflictingEvents = exports.doTimePeriodsOverlap = exports.addWeeks = exports.addDays = void 0;\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _helpers = require(\"./helpers\");\nvar addDays = exports.addDays = function addDays(date, days) {\n  var result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result;\n};\nvar addWeeks = exports.addWeeks = function addWeeks(date, weeks) {\n  return addDays(date, weeks * 7);\n};\nvar getNextRecurrence = exports.getNextRecurrence = function getNextRecurrence(event) {\n  var fromDate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();\n  if (!event.isRecurring || !event.recurrencePattern) {\n    return null;\n  }\n  var _event$recurrencePatt = event.recurrencePattern,\n    type = _event$recurrencePatt.type,\n    interval = _event$recurrencePatt.interval,\n    endDate = _event$recurrencePatt.endDate;\n  var nextDate = new Date(event.startTime);\n  while (nextDate <= fromDate) {\n    switch (type) {\n      case 'daily':\n        nextDate = addDays(nextDate, interval);\n        break;\n      case 'weekly':\n        nextDate = addWeeks(nextDate, interval);\n        break;\n      case 'custom':\n        nextDate = addDays(nextDate, interval);\n        break;\n    }\n  }\n  if (endDate && nextDate > endDate) {\n    return null;\n  }\n  return nextDate;\n};\nvar generateRecurringEvents = exports.generateRecurringEvents = function generateRecurringEvents(baseEvent, startDate, endDate) {\n  if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n    return [];\n  }\n  var events = [];\n  var _baseEvent$recurrence = baseEvent.recurrencePattern,\n    type = _baseEvent$recurrence.type,\n    interval = _baseEvent$recurrence.interval,\n    recurrenceEndDate = _baseEvent$recurrence.endDate;\n  var currentDate = new Date(baseEvent.startTime);\n  var rangeEnd = recurrenceEndDate && recurrenceEndDate < endDate ? recurrenceEndDate : endDate;\n  while (currentDate <= rangeEnd) {\n    if (currentDate >= startDate) {\n      var eventCopy = Object.assign({}, baseEvent, {\n        id: `${baseEvent.id}_${(0, _helpers.formatDateString)(currentDate)}`,\n        startTime: new Date(currentDate)\n      });\n      events.push(eventCopy);\n    }\n    switch (type) {\n      case 'daily':\n        currentDate = addDays(currentDate, interval);\n        break;\n      case 'weekly':\n        currentDate = addWeeks(currentDate, interval);\n        break;\n      case 'custom':\n        currentDate = addDays(currentDate, interval);\n        break;\n    }\n  }\n  return events;\n};\nvar getEventsForDate = exports.getEventsForDate = function getEventsForDate(events, targetDate) {\n  var dayStart = new Date(targetDate);\n  dayStart.setHours(0, 0, 0, 0);\n  var dayEnd = new Date(targetDate);\n  dayEnd.setHours(23, 59, 59, 999);\n  var dayEvents = [];\n  events.forEach(function (event) {\n    var eventDate = new Date(event.startTime);\n    eventDate.setHours(0, 0, 0, 0);\n    if (eventDate.getTime() === dayStart.getTime()) {\n      dayEvents.push(event);\n    }\n    if (event.isRecurring && event.recurrencePattern) {\n      var recurringEvents = generateRecurringEvents(event, dayStart, dayEnd);\n      dayEvents.push.apply(dayEvents, (0, _toConsumableArray2.default)(recurringEvents));\n    }\n  });\n  return dayEvents.sort(function (a, b) {\n    return a.startTime.getTime() - b.startTime.getTime();\n  });\n};\nvar doTimePeriodsOverlap = exports.doTimePeriodsOverlap = function doTimePeriodsOverlap(start1, end1, start2, end2) {\n  return start1 < end2 && end1 > start2;\n};\nvar getEventEndTime = exports.getEventEndTime = function getEventEndTime(event) {\n  return new Date(event.startTime.getTime() + event.duration * 60000);\n};\nvar findConflictingEvents = exports.findConflictingEvents = function findConflictingEvents(targetEvent, allEvents) {\n  var targetEnd = getEventEndTime(targetEvent);\n  return allEvents.filter(function (event) {\n    if (event.id === targetEvent.id) return false;\n    var eventEnd = getEventEndTime(event);\n    return doTimePeriodsOverlap(targetEvent.startTime, targetEnd, event.startTime, eventEnd);\n  });\n};\nvar getAvailableTimeSlots = exports.getAvailableTimeSlots = function getAvailableTimeSlots(events, date) {\n  var slotDuration = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 60;\n  var workingHours = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n    start: '09:00',\n    end: '17:00'\n  };\n  var dayEvents = getEventsForDate(events, date);\n  var availableSlots = [];\n  var _workingHours$start$s = workingHours.start.split(':').map(Number),\n    _workingHours$start$s2 = (0, _slicedToArray2.default)(_workingHours$start$s, 2),\n    startHour = _workingHours$start$s2[0],\n    startMinute = _workingHours$start$s2[1];\n  var _workingHours$end$spl = workingHours.end.split(':').map(Number),\n    _workingHours$end$spl2 = (0, _slicedToArray2.default)(_workingHours$end$spl, 2),\n    endHour = _workingHours$end$spl2[0],\n    endMinute = _workingHours$end$spl2[1];\n  var workStart = new Date(date);\n  workStart.setHours(startHour, startMinute, 0, 0);\n  var workEnd = new Date(date);\n  workEnd.setHours(endHour, endMinute, 0, 0);\n  var sortedEvents = dayEvents.sort(function (a, b) {\n    return a.startTime.getTime() - b.startTime.getTime();\n  });\n  var currentTime = new Date(workStart);\n  for (var event of sortedEvents) {\n    if (event.startTime > currentTime) {\n      var gapDuration = (event.startTime.getTime() - currentTime.getTime()) / 60000;\n      if (gapDuration >= slotDuration) {\n        availableSlots.push({\n          start: new Date(currentTime),\n          end: new Date(event.startTime)\n        });\n      }\n    }\n    var eventEnd = getEventEndTime(event);\n    if (eventEnd > currentTime) {\n      currentTime = new Date(eventEnd);\n    }\n  }\n  if (currentTime < workEnd) {\n    var remainingDuration = (workEnd.getTime() - currentTime.getTime()) / 60000;\n    if (remainingDuration >= slotDuration) {\n      availableSlots.push({\n        start: new Date(currentTime),\n        end: new Date(workEnd)\n      });\n    }\n  }\n  return availableSlots;\n};\nvar suggestOptimalTime = exports.suggestOptimalTime = function suggestOptimalTime(events, date, duration, preferredTime) {\n  var availableSlots = getAvailableTimeSlots(events, date, duration);\n  if (availableSlots.length === 0) {\n    return null;\n  }\n  if (preferredTime) {\n    var _preferredTime$split$ = preferredTime.split(':').map(Number),\n      _preferredTime$split$2 = (0, _slicedToArray2.default)(_preferredTime$split$, 2),\n      hour = _preferredTime$split$2[0],\n      minute = _preferredTime$split$2[1];\n    var preferred = new Date(date);\n    preferred.setHours(hour, minute, 0, 0);\n    var suitableSlot = availableSlots.find(function (slot) {\n      var slotDuration = (slot.end.getTime() - slot.start.getTime()) / 60000;\n      return slot.start <= preferred && preferred.getTime() + duration * 60000 <= slot.end.getTime() && slotDuration >= duration;\n    });\n    if (suitableSlot) {\n      return new Date(Math.max(preferred.getTime(), suitableSlot.start.getTime()));\n    }\n  }\n  return availableSlots[0].start;\n};\nvar getTotalScheduledTime = exports.getTotalScheduledTime = function getTotalScheduledTime(events, date) {\n  var dayEvents = getEventsForDate(events, date);\n  return dayEvents.reduce(function (total, event) {\n    return total + event.duration;\n  }, 0);\n};\nvar getEventsInRange = exports.getEventsInRange = function getEventsInRange(events, startDate, endDate) {\n  var rangeEvents = [];\n  var currentDate = new Date(startDate);\n  while (currentDate <= endDate) {\n    var dayEvents = getEventsForDate(events, currentDate);\n    rangeEvents.push.apply(rangeEvents, (0, _toConsumableArray2.default)(dayEvents));\n    currentDate = addDays(currentDate, 1);\n  }\n  return rangeEvents;\n};","map":{"version":3,"names":["_helpers","require","addDays","exports","date","days","result","Date","setDate","getDate","addWeeks","weeks","getNextRecurrence","event","fromDate","arguments","length","undefined","isRecurring","recurrencePattern","_event$recurrencePatt","type","interval","endDate","nextDate","startTime","generateRecurringEvents","baseEvent","startDate","events","_baseEvent$recurrence","recurrenceEndDate","currentDate","rangeEnd","eventCopy","Object","assign","id","formatDateString","push","getEventsForDate","targetDate","dayStart","setHours","dayEnd","dayEvents","forEach","eventDate","getTime","recurringEvents","apply","_toConsumableArray2","default","sort","a","b","doTimePeriodsOverlap","start1","end1","start2","end2","getEventEndTime","duration","findConflictingEvents","targetEvent","allEvents","targetEnd","filter","eventEnd","getAvailableTimeSlots","slotDuration","workingHours","start","end","availableSlots","_workingHours$start$s","split","map","Number","_workingHours$start$s2","_slicedToArray2","startHour","startMinute","_workingHours$end$spl","_workingHours$end$spl2","endHour","endMinute","workStart","workEnd","sortedEvents","currentTime","gapDuration","remainingDuration","suggestOptimalTime","preferredTime","_preferredTime$split$","_preferredTime$split$2","hour","minute","preferred","suitableSlot","find","slot","Math","max","getTotalScheduledTime","reduce","total","getEventsInRange","rangeEvents"],"sources":["/Users/vaishnavkrishnan/Documents/projects/pd_app/src/utils/dateUtils.ts"],"sourcesContent":["import { TimetableEvent, RecurrencePattern } from '../types';\nimport { formatDateString } from './helpers';\n\n/**\n * Date manipulation utilities for timetable management\n */\n\n/**\n * Adds days to a date\n */\nexport const addDays = (date: Date, days: number): Date => {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result;\n};\n\n/**\n * Adds weeks to a date\n */\nexport const addWeeks = (date: Date, weeks: number): Date => {\n  return addDays(date, weeks * 7);\n};\n\n/**\n * Gets the next occurrence of a recurring event\n */\nexport const getNextRecurrence = (event: TimetableEvent, fromDate: Date = new Date()): Date | null => {\n  if (!event.isRecurring || !event.recurrencePattern) {\n    return null;\n  }\n\n  const { type, interval, endDate } = event.recurrencePattern;\n  let nextDate = new Date(event.startTime);\n\n  // Find the next occurrence after fromDate\n  while (nextDate <= fromDate) {\n    switch (type) {\n      case 'daily':\n        nextDate = addDays(nextDate, interval);\n        break;\n      case 'weekly':\n        nextDate = addWeeks(nextDate, interval);\n        break;\n      case 'custom':\n        // For custom recurrence, treat as daily for now\n        nextDate = addDays(nextDate, interval);\n        break;\n    }\n  }\n\n  // Check if the next occurrence is beyond the end date\n  if (endDate && nextDate > endDate) {\n    return null;\n  }\n\n  return nextDate;\n};\n\n/**\n * Generates all recurring events for a date range\n */\nexport const generateRecurringEvents = (\n  baseEvent: TimetableEvent,\n  startDate: Date,\n  endDate: Date\n): TimetableEvent[] => {\n  if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n    return [];\n  }\n\n  const events: TimetableEvent[] = [];\n  const { type, interval, endDate: recurrenceEndDate } = baseEvent.recurrencePattern;\n  \n  let currentDate = new Date(baseEvent.startTime);\n  const rangeEnd = recurrenceEndDate && recurrenceEndDate < endDate ? recurrenceEndDate : endDate;\n\n  while (currentDate <= rangeEnd) {\n    if (currentDate >= startDate) {\n      const eventCopy: TimetableEvent = {\n        ...baseEvent,\n        id: `${baseEvent.id}_${formatDateString(currentDate)}`,\n        startTime: new Date(currentDate),\n      };\n      events.push(eventCopy);\n    }\n\n    switch (type) {\n      case 'daily':\n        currentDate = addDays(currentDate, interval);\n        break;\n      case 'weekly':\n        currentDate = addWeeks(currentDate, interval);\n        break;\n      case 'custom':\n        currentDate = addDays(currentDate, interval);\n        break;\n    }\n  }\n\n  return events;\n};\n\n/**\n * Gets all events for a specific date, including recurring events\n */\nexport const getEventsForDate = (\n  events: TimetableEvent[],\n  targetDate: Date\n): TimetableEvent[] => {\n  const dayStart = new Date(targetDate);\n  dayStart.setHours(0, 0, 0, 0);\n  \n  const dayEnd = new Date(targetDate);\n  dayEnd.setHours(23, 59, 59, 999);\n\n  const dayEvents: TimetableEvent[] = [];\n\n  events.forEach(event => {\n    // Check if it's a regular event on this date\n    const eventDate = new Date(event.startTime);\n    eventDate.setHours(0, 0, 0, 0);\n    \n    if (eventDate.getTime() === dayStart.getTime()) {\n      dayEvents.push(event);\n    }\n    \n    // Check for recurring events\n    if (event.isRecurring && event.recurrencePattern) {\n      const recurringEvents = generateRecurringEvents(event, dayStart, dayEnd);\n      dayEvents.push(...recurringEvents);\n    }\n  });\n\n  // Sort events by start time\n  return dayEvents.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());\n};\n\n/**\n * Checks if two time periods overlap\n */\nexport const doTimePeriodsOverlap = (\n  start1: Date,\n  end1: Date,\n  start2: Date,\n  end2: Date\n): boolean => {\n  return start1 < end2 && end1 > start2;\n};\n\n/**\n * Gets the end time of an event\n */\nexport const getEventEndTime = (event: TimetableEvent): Date => {\n  return new Date(event.startTime.getTime() + event.duration * 60000);\n};\n\n/**\n * Finds conflicting events for a given event\n */\nexport const findConflictingEvents = (\n  targetEvent: TimetableEvent,\n  allEvents: TimetableEvent[]\n): TimetableEvent[] => {\n  const targetEnd = getEventEndTime(targetEvent);\n  \n  return allEvents.filter(event => {\n    if (event.id === targetEvent.id) return false;\n    \n    const eventEnd = getEventEndTime(event);\n    return doTimePeriodsOverlap(\n      targetEvent.startTime,\n      targetEnd,\n      event.startTime,\n      eventEnd\n    );\n  });\n};\n\n/**\n * Gets available time slots for a given date\n */\nexport const getAvailableTimeSlots = (\n  events: TimetableEvent[],\n  date: Date,\n  slotDuration: number = 60, // in minutes\n  workingHours: { start: string; end: string } = { start: '09:00', end: '17:00' }\n): { start: Date; end: Date }[] => {\n  const dayEvents = getEventsForDate(events, date);\n  const availableSlots: { start: Date; end: Date }[] = [];\n  \n  // Parse working hours\n  const [startHour, startMinute] = workingHours.start.split(':').map(Number);\n  const [endHour, endMinute] = workingHours.end.split(':').map(Number);\n  \n  const workStart = new Date(date);\n  workStart.setHours(startHour, startMinute, 0, 0);\n  \n  const workEnd = new Date(date);\n  workEnd.setHours(endHour, endMinute, 0, 0);\n  \n  // Sort events by start time\n  const sortedEvents = dayEvents.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());\n  \n  let currentTime = new Date(workStart);\n  \n  for (const event of sortedEvents) {\n    // Check if there's a gap before this event\n    if (event.startTime > currentTime) {\n      const gapDuration = (event.startTime.getTime() - currentTime.getTime()) / 60000;\n      if (gapDuration >= slotDuration) {\n        availableSlots.push({\n          start: new Date(currentTime),\n          end: new Date(event.startTime),\n        });\n      }\n    }\n    \n    // Move current time to after this event\n    const eventEnd = getEventEndTime(event);\n    if (eventEnd > currentTime) {\n      currentTime = new Date(eventEnd);\n    }\n  }\n  \n  // Check if there's time after the last event\n  if (currentTime < workEnd) {\n    const remainingDuration = (workEnd.getTime() - currentTime.getTime()) / 60000;\n    if (remainingDuration >= slotDuration) {\n      availableSlots.push({\n        start: new Date(currentTime),\n        end: new Date(workEnd),\n      });\n    }\n  }\n  \n  return availableSlots;\n};\n\n/**\n * Suggests optimal time for a new event\n */\nexport const suggestOptimalTime = (\n  events: TimetableEvent[],\n  date: Date,\n  duration: number,\n  preferredTime?: string // HH:MM format\n): Date | null => {\n  const availableSlots = getAvailableTimeSlots(events, date, duration);\n  \n  if (availableSlots.length === 0) {\n    return null;\n  }\n  \n  // If preferred time is specified, try to find a slot around that time\n  if (preferredTime) {\n    const [hour, minute] = preferredTime.split(':').map(Number);\n    const preferred = new Date(date);\n    preferred.setHours(hour, minute, 0, 0);\n    \n    // Find the slot that contains or is closest to the preferred time\n    const suitableSlot = availableSlots.find(slot => {\n      const slotDuration = (slot.end.getTime() - slot.start.getTime()) / 60000;\n      return slot.start <= preferred && \n             preferred.getTime() + (duration * 60000) <= slot.end.getTime() &&\n             slotDuration >= duration;\n    });\n    \n    if (suitableSlot) {\n      return new Date(Math.max(preferred.getTime(), suitableSlot.start.getTime()));\n    }\n  }\n  \n  // Return the start of the first available slot\n  return availableSlots[0].start;\n};\n\n/**\n * Calculates the total scheduled time for a date\n */\nexport const getTotalScheduledTime = (events: TimetableEvent[], date: Date): number => {\n  const dayEvents = getEventsForDate(events, date);\n  return dayEvents.reduce((total, event) => total + event.duration, 0);\n};\n\n/**\n * Gets events within a date range\n */\nexport const getEventsInRange = (\n  events: TimetableEvent[],\n  startDate: Date,\n  endDate: Date\n): TimetableEvent[] => {\n  const rangeEvents: TimetableEvent[] = [];\n  \n  let currentDate = new Date(startDate);\n  while (currentDate <= endDate) {\n    const dayEvents = getEventsForDate(events, currentDate);\n    rangeEvents.push(...dayEvents);\n    currentDate = addDays(currentDate, 1);\n  }\n  \n  return rangeEvents;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}