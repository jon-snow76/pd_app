{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recurringEventsService = exports.default = void 0;\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar _dateFns = require(\"date-fns\");\nvar _types = require(\"../types\");\nvar RecurringEventsService = function () {\n  function RecurringEventsService() {\n    (0, _classCallCheck2.default)(this, RecurringEventsService);\n  }\n  return (0, _createClass2.default)(RecurringEventsService, [{\n    key: \"generateRecurringInstances\",\n    value: function generateRecurringInstances(baseEvent, startDate, endDate) {\n      if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n        return [];\n      }\n      var instances = [];\n      var pattern = baseEvent.recurrencePattern;\n      var currentDate = new Date(baseEvent.startTime);\n      if ((0, _dateFns.isBefore)(currentDate, startDate)) {\n        currentDate = this.findNextOccurrence(baseEvent, startDate);\n      }\n      var iterationCount = 0;\n      var maxIterations = 1000;\n      while (currentDate <= endDate && iterationCount < maxIterations && (!pattern.endDate || currentDate <= pattern.endDate)) {\n        if (currentDate >= startDate) {\n          var instance = this.createEventInstance(baseEvent, currentDate);\n          instances.push(instance);\n        }\n        currentDate = this.getNextOccurrence(currentDate, pattern);\n        iterationCount++;\n      }\n      return instances;\n    }\n  }, {\n    key: \"createEventInstance\",\n    value: function createEventInstance(baseEvent, date) {\n      var eventDate = new Date(date);\n      var originalDate = new Date(baseEvent.startTime);\n      eventDate.setHours(originalDate.getHours(), originalDate.getMinutes(), originalDate.getSeconds(), originalDate.getMilliseconds());\n      return Object.assign({}, baseEvent, {\n        id: `${baseEvent.id}_${date.toISOString().split('T')[0]}`,\n        startTime: eventDate,\n        isRecurringInstance: true,\n        parentEventId: baseEvent.id\n      });\n    }\n  }, {\n    key: \"findNextOccurrence\",\n    value: function findNextOccurrence(baseEvent, fromDate) {\n      if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n        return new Date(baseEvent.startTime);\n      }\n      var pattern = baseEvent.recurrencePattern;\n      var currentDate = new Date(baseEvent.startTime);\n      if (currentDate >= fromDate) {\n        return currentDate;\n      }\n      while (currentDate < fromDate) {\n        currentDate = this.getNextOccurrence(currentDate, pattern);\n      }\n      return currentDate;\n    }\n  }, {\n    key: \"getNextOccurrence\",\n    value: function getNextOccurrence(currentDate, pattern) {\n      switch (pattern.type) {\n        case 'daily':\n          return (0, _dateFns.addDays)(currentDate, pattern.interval || 1);\n        case 'weekly':\n          return (0, _dateFns.addWeeks)(currentDate, pattern.interval || 1);\n        case 'monthly':\n          return (0, _dateFns.addMonths)(currentDate, pattern.interval || 1);\n        case 'custom':\n          return (0, _dateFns.addDays)(currentDate, pattern.interval || 1);\n        default:\n          return (0, _dateFns.addDays)(currentDate, 1);\n      }\n    }\n  }, {\n    key: \"shouldEventOccurOnDate\",\n    value: function shouldEventOccurOnDate(baseEvent, targetDate) {\n      if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n        return (0, _dateFns.isSameDay)(baseEvent.startTime, targetDate);\n      }\n      var pattern = baseEvent.recurrencePattern;\n      var baseDate = (0, _dateFns.startOfDay)(baseEvent.startTime);\n      var checkDate = (0, _dateFns.startOfDay)(targetDate);\n      if (checkDate < baseDate) {\n        return false;\n      }\n      if (pattern.endDate && checkDate > (0, _dateFns.startOfDay)(pattern.endDate)) {\n        return false;\n      }\n      var daysDiff = Math.floor((checkDate.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24));\n      switch (pattern.type) {\n        case 'daily':\n          return daysDiff % (pattern.interval || 1) === 0;\n        case 'weekly':\n          return daysDiff % ((pattern.interval || 1) * 7) === 0;\n        case 'monthly':\n          var baseDay = baseDate.getDate();\n          var targetDay = checkDate.getDate();\n          var monthsDiff = (checkDate.getFullYear() - baseDate.getFullYear()) * 12 + (checkDate.getMonth() - baseDate.getMonth());\n          return baseDay === targetDay && monthsDiff % (pattern.interval || 1) === 0;\n        case 'custom':\n          return daysDiff % (pattern.interval || 1) === 0;\n        default:\n          return false;\n      }\n    }\n  }, {\n    key: \"getRecurringEventsForDate\",\n    value: function getRecurringEventsForDate(recurringEvents, targetDate) {\n      var _this = this;\n      return recurringEvents.filter(function (event) {\n        return _this.shouldEventOccurOnDate(event, targetDate);\n      }).map(function (event) {\n        return _this.createEventInstance(event, targetDate);\n      });\n    }\n  }, {\n    key: \"validateRecurrencePattern\",\n    value: function validateRecurrencePattern(pattern) {\n      if (!pattern.type) {\n        return false;\n      }\n      if (pattern.interval && pattern.interval < 1) {\n        return false;\n      }\n      if (pattern.endDate && pattern.endDate <= new Date()) {\n        return false;\n      }\n      return true;\n    }\n  }, {\n    key: \"getRecurrenceDescription\",\n    value: function getRecurrenceDescription(pattern) {\n      var interval = pattern.interval || 1;\n      switch (pattern.type) {\n        case 'daily':\n          return interval === 1 ? 'Daily' : `Every ${interval} days`;\n        case 'weekly':\n          return interval === 1 ? 'Weekly' : `Every ${interval} weeks`;\n        case 'monthly':\n          return interval === 1 ? 'Monthly' : `Every ${interval} months`;\n        case 'custom':\n          return `Every ${interval} days (custom)`;\n        default:\n          return 'Unknown pattern';\n      }\n    }\n  }, {\n    key: \"getUpcomingOccurrences\",\n    value: function getUpcomingOccurrences(baseEvent) {\n      var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n      if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n        return [baseEvent.startTime];\n      }\n      var occurrences = [];\n      var pattern = baseEvent.recurrencePattern;\n      var currentDate = new Date(baseEvent.startTime);\n      var today = new Date();\n      if (currentDate < today) {\n        currentDate = this.findNextOccurrence(baseEvent, today);\n      }\n      var iterationCount = 0;\n      var maxIterations = count * 10;\n      while (occurrences.length < count && iterationCount < maxIterations && (!pattern.endDate || currentDate <= pattern.endDate)) {\n        occurrences.push(new Date(currentDate));\n        currentDate = this.getNextOccurrence(currentDate, pattern);\n        iterationCount++;\n      }\n      return occurrences;\n    }\n  }]);\n}();\nvar recurringEventsService = exports.recurringEventsService = new RecurringEventsService();\nvar _default = exports.default = RecurringEventsService;","map":{"version":3,"names":["_dateFns","require","_types","RecurringEventsService","_classCallCheck2","default","_createClass2","key","value","generateRecurringInstances","baseEvent","startDate","endDate","isRecurring","recurrencePattern","instances","pattern","currentDate","Date","startTime","isBefore","findNextOccurrence","iterationCount","maxIterations","instance","createEventInstance","push","getNextOccurrence","date","eventDate","originalDate","setHours","getHours","getMinutes","getSeconds","getMilliseconds","Object","assign","id","toISOString","split","isRecurringInstance","parentEventId","fromDate","type","addDays","interval","addWeeks","addMonths","shouldEventOccurOnDate","targetDate","isSameDay","baseDate","startOfDay","checkDate","daysDiff","Math","floor","getTime","baseDay","getDate","targetDay","monthsDiff","getFullYear","getMonth","getRecurringEventsForDate","recurringEvents","_this","filter","event","map","validateRecurrencePattern","getRecurrenceDescription","getUpcomingOccurrences","count","arguments","length","undefined","occurrences","today","recurringEventsService","exports","_default"],"sources":["/Users/vaishnavkrishnan/Desktop/pd_app/src/services/RecurringEventsService.ts"],"sourcesContent":["import { addDays, addWeeks, addMonths, startOfDay, endOfDay, isSameDay, isAfter, isBefore } from 'date-fns';\nimport { TimetableEvent } from '../types';\n\n/**\n * Service for managing recurring events\n */\nclass RecurringEventsService {\n    /**\n     * Generate recurring event instances for a date range\n     */\n    generateRecurringInstances(\n        baseEvent: TimetableEvent,\n        startDate: Date,\n        endDate: Date\n    ): TimetableEvent[] {\n        if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n            return [];\n        }\n\n        const instances: TimetableEvent[] = [];\n        const pattern = baseEvent.recurrencePattern;\n        let currentDate = new Date(baseEvent.startTime);\n\n        // Ensure we start from the base event date or later\n        if (isBefore(currentDate, startDate)) {\n            currentDate = this.findNextOccurrence(baseEvent, startDate);\n        }\n\n        let iterationCount = 0;\n        const maxIterations = 1000; // Prevent infinite loops\n\n        while (\n            currentDate <= endDate &&\n            iterationCount < maxIterations &&\n            (!pattern.endDate || currentDate <= pattern.endDate)\n        ) {\n            if (currentDate >= startDate) {\n                const instance = this.createEventInstance(baseEvent, currentDate);\n                instances.push(instance);\n            }\n\n            currentDate = this.getNextOccurrence(currentDate, pattern);\n            iterationCount++;\n        }\n\n        return instances;\n    }\n\n    /**\n     * Create a single event instance for a specific date\n     */\n    createEventInstance(baseEvent: TimetableEvent, date: Date): TimetableEvent {\n        const eventDate = new Date(date);\n        const originalDate = new Date(baseEvent.startTime);\n\n        // Preserve the time from the original event\n        eventDate.setHours(\n            originalDate.getHours(),\n            originalDate.getMinutes(),\n            originalDate.getSeconds(),\n            originalDate.getMilliseconds()\n        );\n\n        return {\n            ...baseEvent,\n            id: `${baseEvent.id}_${date.toISOString().split('T')[0]}`,\n            startTime: eventDate,\n            isRecurringInstance: true,\n            parentEventId: baseEvent.id,\n        };\n    }\n\n    /**\n     * Find the next occurrence of a recurring event from a given date\n     */\n    findNextOccurrence(baseEvent: TimetableEvent, fromDate: Date): Date {\n        if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n            return new Date(baseEvent.startTime);\n        }\n\n        const pattern = baseEvent.recurrencePattern;\n        let currentDate = new Date(baseEvent.startTime);\n\n        // If the base event is after the from date, return it\n        if (currentDate >= fromDate) {\n            return currentDate;\n        }\n\n        // Find the next occurrence\n        while (currentDate < fromDate) {\n            currentDate = this.getNextOccurrence(currentDate, pattern);\n        }\n\n        return currentDate;\n    }\n\n    /**\n     * Get the next occurrence date based on recurrence pattern\n     */\n    private getNextOccurrence(currentDate: Date, pattern: RecurrencePattern): Date {\n        switch (pattern.type) {\n            case 'daily':\n                return addDays(currentDate, pattern.interval || 1);\n\n            case 'weekly':\n                return addWeeks(currentDate, pattern.interval || 1);\n\n            case 'monthly':\n                return addMonths(currentDate, pattern.interval || 1);\n\n            case 'custom':\n                // For custom patterns, we'll use daily as default\n                // This can be extended to support more complex patterns\n                return addDays(currentDate, pattern.interval || 1);\n\n            default:\n                return addDays(currentDate, 1);\n        }\n    }\n\n    /**\n     * Check if an event should occur on a specific date\n     */\n    shouldEventOccurOnDate(baseEvent: TimetableEvent, targetDate: Date): boolean {\n        if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n            return isSameDay(baseEvent.startTime, targetDate);\n        }\n\n        const pattern = baseEvent.recurrencePattern;\n        const baseDate = startOfDay(baseEvent.startTime);\n        const checkDate = startOfDay(targetDate);\n\n        // Check if the target date is before the base event\n        if (checkDate < baseDate) {\n            return false;\n        }\n\n        // Check if the target date is after the end date\n        if (pattern.endDate && checkDate > startOfDay(pattern.endDate)) {\n            return false;\n        }\n\n        // Calculate if the date matches the recurrence pattern\n        const daysDiff = Math.floor((checkDate.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24));\n\n        switch (pattern.type) {\n            case 'daily':\n                return daysDiff % (pattern.interval || 1) === 0;\n\n            case 'weekly':\n                return daysDiff % ((pattern.interval || 1) * 7) === 0;\n\n            case 'monthly':\n                // For monthly, we check if it's the same day of the month\n                const baseDay = baseDate.getDate();\n                const targetDay = checkDate.getDate();\n                const monthsDiff = (checkDate.getFullYear() - baseDate.getFullYear()) * 12 +\n                    (checkDate.getMonth() - baseDate.getMonth());\n                return baseDay === targetDay && monthsDiff % (pattern.interval || 1) === 0;\n\n            case 'custom':\n                // Custom logic can be implemented here\n                return daysDiff % (pattern.interval || 1) === 0;\n\n            default:\n                return false;\n        }\n    }\n\n    /**\n     * Get all recurring events for a specific date\n     */\n    getRecurringEventsForDate(recurringEvents: TimetableEvent[], targetDate: Date): TimetableEvent[] {\n        return recurringEvents\n            .filter(event => this.shouldEventOccurOnDate(event, targetDate))\n            .map(event => this.createEventInstance(event, targetDate));\n    }\n\n    /**\n     * Validate recurrence pattern\n     */\n    validateRecurrencePattern(pattern: RecurrencePattern): boolean {\n        if (!pattern.type) {\n            return false;\n        }\n\n        if (pattern.interval && pattern.interval < 1) {\n            return false;\n        }\n\n        if (pattern.endDate && pattern.endDate <= new Date()) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Get human-readable description of recurrence pattern\n     */\n    getRecurrenceDescription(pattern: RecurrencePattern): string {\n        const interval = pattern.interval || 1;\n\n        switch (pattern.type) {\n            case 'daily':\n                return interval === 1 ? 'Daily' : `Every ${interval} days`;\n\n            case 'weekly':\n                return interval === 1 ? 'Weekly' : `Every ${interval} weeks`;\n\n            case 'monthly':\n                return interval === 1 ? 'Monthly' : `Every ${interval} months`;\n\n            case 'custom':\n                return `Every ${interval} days (custom)`;\n\n            default:\n                return 'Unknown pattern';\n        }\n    }\n\n    /**\n     * Calculate the next few occurrences of a recurring event\n     */\n    getUpcomingOccurrences(baseEvent: TimetableEvent, count: number = 5): Date[] {\n        if (!baseEvent.isRecurring || !baseEvent.recurrencePattern) {\n            return [baseEvent.startTime];\n        }\n\n        const occurrences: Date[] = [];\n        const pattern = baseEvent.recurrencePattern;\n        let currentDate = new Date(baseEvent.startTime);\n\n        // Start from today if the base event is in the past\n        const today = new Date();\n        if (currentDate < today) {\n            currentDate = this.findNextOccurrence(baseEvent, today);\n        }\n\n        let iterationCount = 0;\n        const maxIterations = count * 10; // Prevent infinite loops\n\n        while (\n            occurrences.length < count &&\n            iterationCount < maxIterations &&\n            (!pattern.endDate || currentDate <= pattern.endDate)\n        ) {\n            occurrences.push(new Date(currentDate));\n            currentDate = this.getNextOccurrence(currentDate, pattern);\n            iterationCount++;\n        }\n\n        return occurrences;\n    }\n}\n\n// Types\nexport interface RecurrencePattern {\n    type: 'daily' | 'weekly' | 'monthly' | 'custom';\n    interval?: number; // Every N days/weeks/months\n    endDate?: Date;\n    daysOfWeek?: number[]; // For weekly patterns (0 = Sunday, 1 = Monday, etc.)\n    dayOfMonth?: number; // For monthly patterns\n}\n\n// Extend the TimetableEvent type to include recurring instance properties\ndeclare module '../types' {\n    interface TimetableEvent {\n        isRecurringInstance?: boolean;\n        parentEventId?: string;\n    }\n}\n\n// Export singleton instance\nexport const recurringEventsService = new RecurringEventsService();\nexport default RecurringEventsService;"],"mappings":";;;;;;;AAAA,IAAAA,QAAA,GAAAC,OAAA;AACA,IAAAC,MAAA,GAAAD,OAAA;AAA0C,IAKpCE,sBAAsB;EAAA,SAAAA,uBAAA;IAAA,IAAAC,gBAAA,CAAAC,OAAA,QAAAF,sBAAA;EAAA;EAAA,WAAAG,aAAA,CAAAD,OAAA,EAAAF,sBAAA;IAAAI,GAAA;IAAAC,KAAA,EAIxB,SAAAC,0BAA0BA,CACtBC,SAAyB,EACzBC,SAAe,EACfC,OAAa,EACG;MAChB,IAAI,CAACF,SAAS,CAACG,WAAW,IAAI,CAACH,SAAS,CAACI,iBAAiB,EAAE;QACxD,OAAO,EAAE;MACb;MAEA,IAAMC,SAA2B,GAAG,EAAE;MACtC,IAAMC,OAAO,GAAGN,SAAS,CAACI,iBAAiB;MAC3C,IAAIG,WAAW,GAAG,IAAIC,IAAI,CAACR,SAAS,CAACS,SAAS,CAAC;MAG/C,IAAI,IAAAC,iBAAQ,EAACH,WAAW,EAAEN,SAAS,CAAC,EAAE;QAClCM,WAAW,GAAG,IAAI,CAACI,kBAAkB,CAACX,SAAS,EAAEC,SAAS,CAAC;MAC/D;MAEA,IAAIW,cAAc,GAAG,CAAC;MACtB,IAAMC,aAAa,GAAG,IAAI;MAE1B,OACIN,WAAW,IAAIL,OAAO,IACtBU,cAAc,GAAGC,aAAa,KAC7B,CAACP,OAAO,CAACJ,OAAO,IAAIK,WAAW,IAAID,OAAO,CAACJ,OAAO,CAAC,EACtD;QACE,IAAIK,WAAW,IAAIN,SAAS,EAAE;UAC1B,IAAMa,QAAQ,GAAG,IAAI,CAACC,mBAAmB,CAACf,SAAS,EAAEO,WAAW,CAAC;UACjEF,SAAS,CAACW,IAAI,CAACF,QAAQ,CAAC;QAC5B;QAEAP,WAAW,GAAG,IAAI,CAACU,iBAAiB,CAACV,WAAW,EAAED,OAAO,CAAC;QAC1DM,cAAc,EAAE;MACpB;MAEA,OAAOP,SAAS;IACpB;EAAC;IAAAR,GAAA;IAAAC,KAAA,EAKD,SAAAiB,mBAAmBA,CAACf,SAAyB,EAAEkB,IAAU,EAAkB;MACvE,IAAMC,SAAS,GAAG,IAAIX,IAAI,CAACU,IAAI,CAAC;MAChC,IAAME,YAAY,GAAG,IAAIZ,IAAI,CAACR,SAAS,CAACS,SAAS,CAAC;MAGlDU,SAAS,CAACE,QAAQ,CACdD,YAAY,CAACE,QAAQ,CAAC,CAAC,EACvBF,YAAY,CAACG,UAAU,CAAC,CAAC,EACzBH,YAAY,CAACI,UAAU,CAAC,CAAC,EACzBJ,YAAY,CAACK,eAAe,CAAC,CACjC,CAAC;MAED,OAAAC,MAAA,CAAAC,MAAA,KACO3B,SAAS;QACZ4B,EAAE,EAAE,GAAG5B,SAAS,CAAC4B,EAAE,IAAIV,IAAI,CAACW,WAAW,CAAC,CAAC,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE;QACzDrB,SAAS,EAAEU,SAAS;QACpBY,mBAAmB,EAAE,IAAI;QACzBC,aAAa,EAAEhC,SAAS,CAAC4B;MAAE;IAEnC;EAAC;IAAA/B,GAAA;IAAAC,KAAA,EAKD,SAAAa,kBAAkBA,CAACX,SAAyB,EAAEiC,QAAc,EAAQ;MAChE,IAAI,CAACjC,SAAS,CAACG,WAAW,IAAI,CAACH,SAAS,CAACI,iBAAiB,EAAE;QACxD,OAAO,IAAII,IAAI,CAACR,SAAS,CAACS,SAAS,CAAC;MACxC;MAEA,IAAMH,OAAO,GAAGN,SAAS,CAACI,iBAAiB;MAC3C,IAAIG,WAAW,GAAG,IAAIC,IAAI,CAACR,SAAS,CAACS,SAAS,CAAC;MAG/C,IAAIF,WAAW,IAAI0B,QAAQ,EAAE;QACzB,OAAO1B,WAAW;MACtB;MAGA,OAAOA,WAAW,GAAG0B,QAAQ,EAAE;QAC3B1B,WAAW,GAAG,IAAI,CAACU,iBAAiB,CAACV,WAAW,EAAED,OAAO,CAAC;MAC9D;MAEA,OAAOC,WAAW;IACtB;EAAC;IAAAV,GAAA;IAAAC,KAAA,EAKD,SAAQmB,iBAAiBA,CAACV,WAAiB,EAAED,OAA0B,EAAQ;MAC3E,QAAQA,OAAO,CAAC4B,IAAI;QAChB,KAAK,OAAO;UACR,OAAO,IAAAC,gBAAO,EAAC5B,WAAW,EAAED,OAAO,CAAC8B,QAAQ,IAAI,CAAC,CAAC;QAEtD,KAAK,QAAQ;UACT,OAAO,IAAAC,iBAAQ,EAAC9B,WAAW,EAAED,OAAO,CAAC8B,QAAQ,IAAI,CAAC,CAAC;QAEvD,KAAK,SAAS;UACV,OAAO,IAAAE,kBAAS,EAAC/B,WAAW,EAAED,OAAO,CAAC8B,QAAQ,IAAI,CAAC,CAAC;QAExD,KAAK,QAAQ;UAGT,OAAO,IAAAD,gBAAO,EAAC5B,WAAW,EAAED,OAAO,CAAC8B,QAAQ,IAAI,CAAC,CAAC;QAEtD;UACI,OAAO,IAAAD,gBAAO,EAAC5B,WAAW,EAAE,CAAC,CAAC;MACtC;IACJ;EAAC;IAAAV,GAAA;IAAAC,KAAA,EAKD,SAAAyC,sBAAsBA,CAACvC,SAAyB,EAAEwC,UAAgB,EAAW;MACzE,IAAI,CAACxC,SAAS,CAACG,WAAW,IAAI,CAACH,SAAS,CAACI,iBAAiB,EAAE;QACxD,OAAO,IAAAqC,kBAAS,EAACzC,SAAS,CAACS,SAAS,EAAE+B,UAAU,CAAC;MACrD;MAEA,IAAMlC,OAAO,GAAGN,SAAS,CAACI,iBAAiB;MAC3C,IAAMsC,QAAQ,GAAG,IAAAC,mBAAU,EAAC3C,SAAS,CAACS,SAAS,CAAC;MAChD,IAAMmC,SAAS,GAAG,IAAAD,mBAAU,EAACH,UAAU,CAAC;MAGxC,IAAII,SAAS,GAAGF,QAAQ,EAAE;QACtB,OAAO,KAAK;MAChB;MAGA,IAAIpC,OAAO,CAACJ,OAAO,IAAI0C,SAAS,GAAG,IAAAD,mBAAU,EAACrC,OAAO,CAACJ,OAAO,CAAC,EAAE;QAC5D,OAAO,KAAK;MAChB;MAGA,IAAM2C,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAAC,CAACH,SAAS,CAACI,OAAO,CAAC,CAAC,GAAGN,QAAQ,CAACM,OAAO,CAAC,CAAC,KAAK,IAAI,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,CAAC;MAE/F,QAAQ1C,OAAO,CAAC4B,IAAI;QAChB,KAAK,OAAO;UACR,OAAOW,QAAQ,IAAIvC,OAAO,CAAC8B,QAAQ,IAAI,CAAC,CAAC,KAAK,CAAC;QAEnD,KAAK,QAAQ;UACT,OAAOS,QAAQ,IAAI,CAACvC,OAAO,CAAC8B,QAAQ,IAAI,CAAC,IAAI,CAAC,CAAC,KAAK,CAAC;QAEzD,KAAK,SAAS;UAEV,IAAMa,OAAO,GAAGP,QAAQ,CAACQ,OAAO,CAAC,CAAC;UAClC,IAAMC,SAAS,GAAGP,SAAS,CAACM,OAAO,CAAC,CAAC;UACrC,IAAME,UAAU,GAAG,CAACR,SAAS,CAACS,WAAW,CAAC,CAAC,GAAGX,QAAQ,CAACW,WAAW,CAAC,CAAC,IAAI,EAAE,IACrET,SAAS,CAACU,QAAQ,CAAC,CAAC,GAAGZ,QAAQ,CAACY,QAAQ,CAAC,CAAC,CAAC;UAChD,OAAOL,OAAO,KAAKE,SAAS,IAAIC,UAAU,IAAI9C,OAAO,CAAC8B,QAAQ,IAAI,CAAC,CAAC,KAAK,CAAC;QAE9E,KAAK,QAAQ;UAET,OAAOS,QAAQ,IAAIvC,OAAO,CAAC8B,QAAQ,IAAI,CAAC,CAAC,KAAK,CAAC;QAEnD;UACI,OAAO,KAAK;MACpB;IACJ;EAAC;IAAAvC,GAAA;IAAAC,KAAA,EAKD,SAAAyD,yBAAyBA,CAACC,eAAiC,EAAEhB,UAAgB,EAAoB;MAAA,IAAAiB,KAAA;MAC7F,OAAOD,eAAe,CACjBE,MAAM,CAAC,UAAAC,KAAK;QAAA,OAAIF,KAAI,CAAClB,sBAAsB,CAACoB,KAAK,EAAEnB,UAAU,CAAC;MAAA,EAAC,CAC/DoB,GAAG,CAAC,UAAAD,KAAK;QAAA,OAAIF,KAAI,CAAC1C,mBAAmB,CAAC4C,KAAK,EAAEnB,UAAU,CAAC;MAAA,EAAC;IAClE;EAAC;IAAA3C,GAAA;IAAAC,KAAA,EAKD,SAAA+D,yBAAyBA,CAACvD,OAA0B,EAAW;MAC3D,IAAI,CAACA,OAAO,CAAC4B,IAAI,EAAE;QACf,OAAO,KAAK;MAChB;MAEA,IAAI5B,OAAO,CAAC8B,QAAQ,IAAI9B,OAAO,CAAC8B,QAAQ,GAAG,CAAC,EAAE;QAC1C,OAAO,KAAK;MAChB;MAEA,IAAI9B,OAAO,CAACJ,OAAO,IAAII,OAAO,CAACJ,OAAO,IAAI,IAAIM,IAAI,CAAC,CAAC,EAAE;QAClD,OAAO,KAAK;MAChB;MAEA,OAAO,IAAI;IACf;EAAC;IAAAX,GAAA;IAAAC,KAAA,EAKD,SAAAgE,wBAAwBA,CAACxD,OAA0B,EAAU;MACzD,IAAM8B,QAAQ,GAAG9B,OAAO,CAAC8B,QAAQ,IAAI,CAAC;MAEtC,QAAQ9B,OAAO,CAAC4B,IAAI;QAChB,KAAK,OAAO;UACR,OAAOE,QAAQ,KAAK,CAAC,GAAG,OAAO,GAAG,SAASA,QAAQ,OAAO;QAE9D,KAAK,QAAQ;UACT,OAAOA,QAAQ,KAAK,CAAC,GAAG,QAAQ,GAAG,SAASA,QAAQ,QAAQ;QAEhE,KAAK,SAAS;UACV,OAAOA,QAAQ,KAAK,CAAC,GAAG,SAAS,GAAG,SAASA,QAAQ,SAAS;QAElE,KAAK,QAAQ;UACT,OAAO,SAASA,QAAQ,gBAAgB;QAE5C;UACI,OAAO,iBAAiB;MAChC;IACJ;EAAC;IAAAvC,GAAA;IAAAC,KAAA,EAKD,SAAAiE,sBAAsBA,CAAC/D,SAAyB,EAA6B;MAAA,IAA3BgE,KAAa,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC;MAC/D,IAAI,CAACjE,SAAS,CAACG,WAAW,IAAI,CAACH,SAAS,CAACI,iBAAiB,EAAE;QACxD,OAAO,CAACJ,SAAS,CAACS,SAAS,CAAC;MAChC;MAEA,IAAM2D,WAAmB,GAAG,EAAE;MAC9B,IAAM9D,OAAO,GAAGN,SAAS,CAACI,iBAAiB;MAC3C,IAAIG,WAAW,GAAG,IAAIC,IAAI,CAACR,SAAS,CAACS,SAAS,CAAC;MAG/C,IAAM4D,KAAK,GAAG,IAAI7D,IAAI,CAAC,CAAC;MACxB,IAAID,WAAW,GAAG8D,KAAK,EAAE;QACrB9D,WAAW,GAAG,IAAI,CAACI,kBAAkB,CAACX,SAAS,EAAEqE,KAAK,CAAC;MAC3D;MAEA,IAAIzD,cAAc,GAAG,CAAC;MACtB,IAAMC,aAAa,GAAGmD,KAAK,GAAG,EAAE;MAEhC,OACII,WAAW,CAACF,MAAM,GAAGF,KAAK,IAC1BpD,cAAc,GAAGC,aAAa,KAC7B,CAACP,OAAO,CAACJ,OAAO,IAAIK,WAAW,IAAID,OAAO,CAACJ,OAAO,CAAC,EACtD;QACEkE,WAAW,CAACpD,IAAI,CAAC,IAAIR,IAAI,CAACD,WAAW,CAAC,CAAC;QACvCA,WAAW,GAAG,IAAI,CAACU,iBAAiB,CAACV,WAAW,EAAED,OAAO,CAAC;QAC1DM,cAAc,EAAE;MACpB;MAEA,OAAOwD,WAAW;IACtB;EAAC;AAAA;AAqBE,IAAME,sBAAsB,GAAAC,OAAA,CAAAD,sBAAA,GAAG,IAAI7E,sBAAsB,CAAC,CAAC;AAAC,IAAA+E,QAAA,GAAAD,OAAA,CAAA5E,OAAA,GACpDF,sBAAsB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}