{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useTimetable = exports.default = exports.TimetableProvider = void 0;\nvar _asyncToGenerator2 = _interopRequireDefault(require(\"@babel/runtime/helpers/asyncToGenerator\"));\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\nvar _react = _interopRequireWildcard(require(\"react\"));\nvar _storage = require(\"../utils/storage\");\nvar _validation = require(\"../utils/validation\");\nvar _dateUtils = require(\"../utils/dateUtils\");\nvar _helpers = require(\"../utils/helpers\");\nvar _useDateNavigation2 = require(\"../hooks/useDateNavigation\");\nvar _useRecurringEvents2 = require(\"../hooks/useRecurringEvents\");\nvar _jsxRuntime = require(\"react/jsx-runtime\");\nvar _this = this,\n  _jsxFileName = \"/Users/vaishnavkrishnan/Desktop/pd_app/src/context/TimetableContext.tsx\";\nfunction _interopRequireWildcard(e, t) { if (\"function\" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function _interopRequireWildcard(e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]); return f; })(e, t); }\nvar initialState = {\n  events: [],\n  recurringEvents: [],\n  selectedDate: new Date(),\n  loading: false,\n  error: null,\n  conflicts: [],\n  viewMode: 'day'\n};\nvar timetableReducer = function timetableReducer(state, action) {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return Object.assign({}, state, {\n        loading: action.payload\n      });\n    case 'SET_ERROR':\n      return Object.assign({}, state, {\n        error: action.payload,\n        loading: false\n      });\n    case 'SET_EVENTS':\n      return Object.assign({}, state, {\n        events: action.payload,\n        loading: false,\n        error: null\n      });\n    case 'SET_RECURRING_EVENTS':\n      return Object.assign({}, state, {\n        recurringEvents: action.payload,\n        loading: false,\n        error: null\n      });\n    case 'SET_SELECTED_DATE':\n      return Object.assign({}, state, {\n        selectedDate: action.payload\n      });\n    case 'SET_VIEW_MODE':\n      return Object.assign({}, state, {\n        viewMode: action.payload\n      });\n    case 'ADD_EVENT':\n      return Object.assign({}, state, {\n        events: [].concat((0, _toConsumableArray2.default)(state.events), [action.payload]),\n        error: null\n      });\n    case 'UPDATE_EVENT':\n      return Object.assign({}, state, {\n        events: state.events.map(function (event) {\n          return event.id === action.payload.id ? action.payload : event;\n        }),\n        error: null\n      });\n    case 'DELETE_EVENT':\n      return Object.assign({}, state, {\n        events: state.events.filter(function (event) {\n          return event.id !== action.payload;\n        }),\n        error: null\n      });\n    case 'SET_CONFLICTS':\n      return Object.assign({}, state, {\n        conflicts: action.payload\n      });\n    case 'CLEAR_CONFLICTS':\n      return Object.assign({}, state, {\n        conflicts: []\n      });\n    default:\n      return state;\n  }\n};\nvar TimetableContext = (0, _react.createContext)(undefined);\nvar TimetableProvider = exports.TimetableProvider = function TimetableProvider(_ref) {\n  var children = _ref.children;\n  var _useReducer = (0, _react.useReducer)(timetableReducer, initialState),\n    _useReducer2 = (0, _slicedToArray2.default)(_useReducer, 2),\n    state = _useReducer2[0],\n    dispatch = _useReducer2[1];\n  var _useDateNavigation = (0, _useDateNavigation2.useDateNavigation)(),\n    currentDate = _useDateNavigation.currentDate;\n  var _useRecurringEvents = (0, _useRecurringEvents2.useRecurringEvents)(),\n    getEventsForDate = _useRecurringEvents.getEventsForDate,\n    getEventsInRange = _useRecurringEvents.getEventsInRange;\n  (0, _react.useEffect)(function () {\n    dispatch({\n      type: 'SET_SELECTED_DATE',\n      payload: currentDate\n    });\n  }, [currentDate]);\n  (0, _react.useEffect)(function () {\n    loadEvents();\n  }, []);\n  var loadEvents = function () {\n    var _ref2 = (0, _asyncToGenerator2.default)(function* () {\n      try {\n        dispatch({\n          type: 'SET_LOADING',\n          payload: true\n        });\n        var events = yield (0, _storage.loadTimetableEvents)();\n        dispatch({\n          type: 'SET_EVENTS',\n          payload: events\n        });\n      } catch (error) {\n        dispatch({\n          type: 'SET_ERROR',\n          payload: 'Failed to load events'\n        });\n        console.error('Error loading events:', error);\n      }\n    });\n    return function loadEvents() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n  var addEvent = function () {\n    var _ref3 = (0, _asyncToGenerator2.default)(function* (eventData) {\n      try {\n        var validation = (0, _validation.validateTimetableEvent)(eventData);\n        if (!validation.isValid) {\n          return validation;\n        }\n        var newEvent = Object.assign({}, eventData, {\n          id: (0, _helpers.generateId)()\n        });\n        var conflicts = (0, _dateUtils.findConflictingEvents)(newEvent, state.events);\n        if (conflicts.length > 0) {\n          dispatch({\n            type: 'SET_CONFLICTS',\n            payload: conflicts\n          });\n          return {\n            isValid: false,\n            errors: [`Event conflicts with ${conflicts.length} existing event(s)`]\n          };\n        }\n        yield (0, _storage.addTimetableEvent)(newEvent);\n        dispatch({\n          type: 'ADD_EVENT',\n          payload: newEvent\n        });\n        dispatch({\n          type: 'CLEAR_CONFLICTS'\n        });\n        return {\n          isValid: true,\n          errors: []\n        };\n      } catch (error) {\n        var errorMessage = 'Failed to add event';\n        dispatch({\n          type: 'SET_ERROR',\n          payload: errorMessage\n        });\n        console.error('Error adding event:', error);\n        return {\n          isValid: false,\n          errors: [errorMessage]\n        };\n      }\n    });\n    return function addEvent(_x) {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n  var updateEvent = function () {\n    var _ref4 = (0, _asyncToGenerator2.default)(function* (updatedEvent) {\n      try {\n        var validation = (0, _validation.validateTimetableEvent)(updatedEvent);\n        if (!validation.isValid) {\n          return validation;\n        }\n        var otherEvents = state.events.filter(function (event) {\n          return event.id !== updatedEvent.id;\n        });\n        var conflicts = (0, _dateUtils.findConflictingEvents)(updatedEvent, otherEvents);\n        if (conflicts.length > 0) {\n          dispatch({\n            type: 'SET_CONFLICTS',\n            payload: conflicts\n          });\n          return {\n            isValid: false,\n            errors: [`Event conflicts with ${conflicts.length} existing event(s)`]\n          };\n        }\n        yield (0, _storage.updateTimetableEvent)(updatedEvent);\n        dispatch({\n          type: 'UPDATE_EVENT',\n          payload: updatedEvent\n        });\n        dispatch({\n          type: 'CLEAR_CONFLICTS'\n        });\n        return {\n          isValid: true,\n          errors: []\n        };\n      } catch (error) {\n        var errorMessage = 'Failed to update event';\n        dispatch({\n          type: 'SET_ERROR',\n          payload: errorMessage\n        });\n        console.error('Error updating event:', error);\n        return {\n          isValid: false,\n          errors: [errorMessage]\n        };\n      }\n    });\n    return function updateEvent(_x2) {\n      return _ref4.apply(this, arguments);\n    };\n  }();\n  var deleteEvent = function () {\n    var _ref5 = (0, _asyncToGenerator2.default)(function* (eventId) {\n      try {\n        yield (0, _storage.deleteTimetableEvent)(eventId);\n        dispatch({\n          type: 'DELETE_EVENT',\n          payload: eventId\n        });\n      } catch (error) {\n        dispatch({\n          type: 'SET_ERROR',\n          payload: 'Failed to delete event'\n        });\n        console.error('Error deleting event:', error);\n      }\n    });\n    return function deleteEvent(_x3) {\n      return _ref5.apply(this, arguments);\n    };\n  }();\n  var addRecurringEvent = function () {\n    var _ref6 = (0, _asyncToGenerator2.default)(function* (eventData, pattern) {\n      try {\n        var validation = (0, _validation.validateTimetableEvent)(eventData);\n        if (!validation.isValid) {\n          return validation;\n        }\n        var newEvent = Object.assign({}, eventData, {\n          id: (0, _helpers.generateId)(),\n          isRecurring: true,\n          recurrencePattern: pattern\n        });\n        yield (0, _storage.addTimetableEvent)(newEvent);\n        dispatch({\n          type: 'SET_RECURRING_EVENTS',\n          payload: [].concat((0, _toConsumableArray2.default)(state.recurringEvents), [newEvent])\n        });\n        dispatch({\n          type: 'CLEAR_CONFLICTS'\n        });\n        return {\n          isValid: true,\n          errors: []\n        };\n      } catch (error) {\n        var errorMessage = 'Failed to add recurring event';\n        dispatch({\n          type: 'SET_ERROR',\n          payload: errorMessage\n        });\n        console.error('Error adding recurring event:', error);\n        return {\n          isValid: false,\n          errors: [errorMessage]\n        };\n      }\n    });\n    return function addRecurringEvent(_x4, _x5) {\n      return _ref6.apply(this, arguments);\n    };\n  }();\n  var updateRecurringEvent = function () {\n    var _ref7 = (0, _asyncToGenerator2.default)(function* (updatedEvent, pattern) {\n      try {\n        var validation = (0, _validation.validateTimetableEvent)(updatedEvent);\n        if (!validation.isValid) {\n          return validation;\n        }\n        if (pattern) {\n          updatedEvent.recurrencePattern = pattern;\n        }\n        yield (0, _storage.updateTimetableEvent)(updatedEvent);\n        if (updatedEvent.isRecurring) {\n          dispatch({\n            type: 'SET_RECURRING_EVENTS',\n            payload: state.recurringEvents.map(function (event) {\n              return event.id === updatedEvent.id ? updatedEvent : event;\n            })\n          });\n        } else {\n          dispatch({\n            type: 'UPDATE_EVENT',\n            payload: updatedEvent\n          });\n        }\n        dispatch({\n          type: 'CLEAR_CONFLICTS'\n        });\n        return {\n          isValid: true,\n          errors: []\n        };\n      } catch (error) {\n        var errorMessage = 'Failed to update recurring event';\n        dispatch({\n          type: 'SET_ERROR',\n          payload: errorMessage\n        });\n        console.error('Error updating recurring event:', error);\n        return {\n          isValid: false,\n          errors: [errorMessage]\n        };\n      }\n    });\n    return function updateRecurringEvent(_x6, _x7) {\n      return _ref7.apply(this, arguments);\n    };\n  }();\n  var deleteRecurringEvent = function () {\n    var _ref8 = (0, _asyncToGenerator2.default)(function* (eventId) {\n      try {\n        yield (0, _storage.deleteTimetableEvent)(eventId);\n        dispatch({\n          type: 'SET_RECURRING_EVENTS',\n          payload: state.recurringEvents.filter(function (event) {\n            return event.id !== eventId;\n          })\n        });\n      } catch (error) {\n        dispatch({\n          type: 'SET_ERROR',\n          payload: 'Failed to delete recurring event'\n        });\n        console.error('Error deleting recurring event:', error);\n      }\n    });\n    return function deleteRecurringEvent(_x8) {\n      return _ref8.apply(this, arguments);\n    };\n  }();\n  var setSelectedDate = function setSelectedDate(date) {\n    dispatch({\n      type: 'SET_SELECTED_DATE',\n      payload: date\n    });\n    dispatch({\n      type: 'CLEAR_CONFLICTS'\n    });\n  };\n  var setViewMode = function setViewMode(mode) {\n    dispatch({\n      type: 'SET_VIEW_MODE',\n      payload: mode\n    });\n  };\n  var getEventsForSelectedDate = function getEventsForSelectedDate() {\n    return getEventsForDate(state.events, state.recurringEvents, state.selectedDate);\n  };\n  var getEventsForDateUtil = function getEventsForDateUtil(date) {\n    return getEventsForDate(state.events, state.recurringEvents, date);\n  };\n  var getEventsInRangeUtil = function getEventsInRangeUtil(startDate, endDate) {\n    return getEventsInRange(state.events, state.recurringEvents, startDate, endDate);\n  };\n  var getCompletedEventsForDate = function getCompletedEventsForDate(date) {\n    var allEvents = getEventsForDate(state.events, state.recurringEvents, date);\n    return allEvents.filter(function (event) {\n      return event.isCompleted;\n    });\n  };\n  var getEventHistory = function getEventHistory(eventId) {\n    var event = state.events.find(function (e) {\n      return e.id === eventId;\n    }) || state.recurringEvents.find(function (e) {\n      return e.id === eventId;\n    });\n    return event ? [event] : [];\n  };\n  var checkEventConflicts = function checkEventConflicts(event) {\n    var conflicts = (0, _dateUtils.findConflictingEvents)(event, state.events);\n    dispatch({\n      type: 'SET_CONFLICTS',\n      payload: conflicts\n    });\n    return conflicts;\n  };\n  var validateAndCheckConflicts = function validateAndCheckConflicts(eventData) {\n    var validation = (0, _validation.validateTimetableEvent)(eventData);\n    if (!validation.isValid) {\n      return validation;\n    }\n    if (eventData.id && eventData.startTime && eventData.duration) {\n      var event = eventData;\n      var conflicts = checkEventConflicts(event);\n      if (conflicts.length > 0) {\n        return {\n          isValid: false,\n          errors: [`Event conflicts with ${conflicts.length} existing event(s)`]\n        };\n      }\n    }\n    return {\n      isValid: true,\n      errors: []\n    };\n  };\n  var clearConflicts = function clearConflicts() {\n    dispatch({\n      type: 'CLEAR_CONFLICTS'\n    });\n  };\n  var getTotalScheduledTimeForDate = function getTotalScheduledTimeForDate(date) {\n    var dayEvents = getEventsForDate(state.events, date);\n    return dayEvents.reduce(function (total, event) {\n      return total + event.duration;\n    }, 0);\n  };\n  var getAvailableSlots = function getAvailableSlots(date) {\n    var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 60;\n    var dayEvents = getEventsForDate(state.events, date);\n    var workingHours = {\n      start: '09:00',\n      end: '17:00'\n    };\n    var slots = [];\n    var _workingHours$start$s = workingHours.start.split(':').map(Number),\n      _workingHours$start$s2 = (0, _slicedToArray2.default)(_workingHours$start$s, 2),\n      startHour = _workingHours$start$s2[0],\n      startMinute = _workingHours$start$s2[1];\n    var workStart = new Date(date);\n    workStart.setHours(startHour, startMinute, 0, 0);\n    var _workingHours$end$spl = workingHours.end.split(':').map(Number),\n      _workingHours$end$spl2 = (0, _slicedToArray2.default)(_workingHours$end$spl, 2),\n      endHour = _workingHours$end$spl2[0],\n      endMinute = _workingHours$end$spl2[1];\n    var workEnd = new Date(date);\n    workEnd.setHours(endHour, endMinute, 0, 0);\n    if (dayEvents.length === 0) {\n      slots.push({\n        start: workStart,\n        end: workEnd\n      });\n    }\n    return slots;\n  };\n  var contextValue = {\n    state: state,\n    loadEvents: loadEvents,\n    addEvent: addEvent,\n    updateEvent: updateEvent,\n    deleteEvent: deleteEvent,\n    addRecurringEvent: addRecurringEvent,\n    updateRecurringEvent: updateRecurringEvent,\n    deleteRecurringEvent: deleteRecurringEvent,\n    setSelectedDate: setSelectedDate,\n    setViewMode: setViewMode,\n    getEventsForSelectedDate: getEventsForSelectedDate,\n    getEventsForDate: getEventsForDateUtil,\n    getEventsInRange: getEventsInRangeUtil,\n    getCompletedEventsForDate: getCompletedEventsForDate,\n    getEventHistory: getEventHistory,\n    checkEventConflicts: checkEventConflicts,\n    validateAndCheckConflicts: validateAndCheckConflicts,\n    clearConflicts: clearConflicts,\n    getTotalScheduledTimeForDate: getTotalScheduledTimeForDate,\n    getAvailableSlots: getAvailableSlots\n  };\n  return (0, _jsxRuntime.jsx)(TimetableContext.Provider, {\n    value: contextValue,\n    children: children\n  });\n};\nvar useTimetable = exports.useTimetable = function useTimetable() {\n  var context = (0, _react.useContext)(TimetableContext);\n  if (context === undefined) {\n    throw new Error('useTimetable must be used within a TimetableProvider');\n  }\n  return context;\n};\nvar _default = exports.default = TimetableContext;","map":{"version":3,"names":["_react","_interopRequireWildcard","require","_storage","_validation","_dateUtils","_helpers","_useDateNavigation2","_useRecurringEvents2","_jsxRuntime","_this","_jsxFileName","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","default","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","initialState","events","recurringEvents","selectedDate","Date","loading","error","conflicts","viewMode","timetableReducer","state","action","type","assign","payload","concat","_toConsumableArray2","map","event","id","filter","TimetableContext","createContext","undefined","TimetableProvider","exports","_ref","children","_useReducer","useReducer","_useReducer2","_slicedToArray2","dispatch","_useDateNavigation","useDateNavigation","currentDate","_useRecurringEvents","useRecurringEvents","getEventsForDate","getEventsInRange","useEffect","loadEvents","_ref2","_asyncToGenerator2","loadTimetableEvents","console","apply","arguments","addEvent","_ref3","eventData","validation","validateTimetableEvent","isValid","newEvent","generateId","findConflictingEvents","length","errors","addEventToStorage","errorMessage","_x","updateEvent","_ref4","updatedEvent","otherEvents","updateEventInStorage","_x2","deleteEvent","_ref5","eventId","deleteEventFromStorage","_x3","addRecurringEvent","_ref6","pattern","isRecurring","recurrencePattern","_x4","_x5","updateRecurringEvent","_ref7","_x6","_x7","deleteRecurringEvent","_ref8","_x8","setSelectedDate","date","setViewMode","mode","getEventsForSelectedDate","getEventsForDateUtil","getEventsInRangeUtil","startDate","endDate","getCompletedEventsForDate","allEvents","isCompleted","getEventHistory","find","checkEventConflicts","validateAndCheckConflicts","startTime","duration","clearConflicts","getTotalScheduledTimeForDate","dayEvents","reduce","total","getAvailableSlots","workingHours","start","end","slots","_workingHours$start$s","split","Number","_workingHours$start$s2","startHour","startMinute","workStart","setHours","_workingHours$end$spl","_workingHours$end$spl2","endHour","endMinute","workEnd","push","contextValue","jsx","Provider","value","useTimetable","context","useContext","Error","_default"],"sources":["/Users/vaishnavkrishnan/Desktop/pd_app/src/context/TimetableContext.tsx"],"sourcesContent":["import React, { createContext, useContext, useReducer, useEffect, ReactNode } from 'react';\nimport { TimetableEvent, ValidationResult } from '../types';\nimport {\n  loadTimetableEvents,\n  saveTimetableEvents,\n  addTimetableEvent as addEventToStorage,\n  updateTimetableEvent as updateEventInStorage,\n  deleteTimetableEvent as deleteEventFromStorage,\n  getTimetableEventsForDate,\n} from '../utils/storage';\nimport {\n  validateTimetableEvent,\n  validateEventConflicts,\n} from '../utils/validation';\nimport {\n  getEventsForDate,\n  findConflictingEvents,\n  generateRecurringEvents,\n} from '../utils/dateUtils';\nimport { generateId } from '../utils/helpers';\nimport { useDateNavigation } from '../hooks/useDateNavigation';\nimport { useRecurringEvents } from '../hooks/useRecurringEvents';\nimport { RecurrencePattern } from '../services/RecurringEventsService';\n\n// State interface\ninterface TimetableState {\n  events: TimetableEvent[];\n  recurringEvents: TimetableEvent[];\n  selectedDate: Date;\n  loading: boolean;\n  error: string | null;\n  conflicts: TimetableEvent[];\n  viewMode: 'day' | 'week' | 'month';\n}\n\n// Action types\ntype TimetableAction =\n  | { type: 'SET_LOADING'; payload: boolean }\n  | { type: 'SET_ERROR'; payload: string | null }\n  | { type: 'SET_EVENTS'; payload: TimetableEvent[] }\n  | { type: 'SET_RECURRING_EVENTS'; payload: TimetableEvent[] }\n  | { type: 'SET_SELECTED_DATE'; payload: Date }\n  | { type: 'SET_VIEW_MODE'; payload: 'day' | 'week' | 'month' }\n  | { type: 'ADD_EVENT'; payload: TimetableEvent }\n  | { type: 'UPDATE_EVENT'; payload: TimetableEvent }\n  | { type: 'DELETE_EVENT'; payload: string }\n  | { type: 'SET_CONFLICTS'; payload: TimetableEvent[] }\n  | { type: 'CLEAR_CONFLICTS' };\n\n// Initial state\nconst initialState: TimetableState = {\n  events: [],\n  recurringEvents: [],\n  selectedDate: new Date(),\n  loading: false,\n  error: null,\n  conflicts: [],\n  viewMode: 'day',\n};\n\n// Reducer function\nconst timetableReducer = (state: TimetableState, action: TimetableAction): TimetableState => {\n  switch (action.type) {\n    case 'SET_LOADING':\n      return { ...state, loading: action.payload };\n    \n    case 'SET_ERROR':\n      return { ...state, error: action.payload, loading: false };\n    \n    case 'SET_EVENTS':\n      return { ...state, events: action.payload, loading: false, error: null };\n    \n    case 'SET_RECURRING_EVENTS':\n      return { ...state, recurringEvents: action.payload, loading: false, error: null };\n    \n    case 'SET_SELECTED_DATE':\n      return { ...state, selectedDate: action.payload };\n    \n    case 'SET_VIEW_MODE':\n      return { ...state, viewMode: action.payload };\n    \n    case 'ADD_EVENT':\n      return {\n        ...state,\n        events: [...state.events, action.payload],\n        error: null,\n      };\n    \n    case 'UPDATE_EVENT':\n      return {\n        ...state,\n        events: state.events.map(event =>\n          event.id === action.payload.id ? action.payload : event\n        ),\n        error: null,\n      };\n    \n    case 'DELETE_EVENT':\n      return {\n        ...state,\n        events: state.events.filter(event => event.id !== action.payload),\n        error: null,\n      };\n    \n    case 'SET_CONFLICTS':\n      return { ...state, conflicts: action.payload };\n    \n    case 'CLEAR_CONFLICTS':\n      return { ...state, conflicts: [] };\n    \n    default:\n      return state;\n  }\n};\n\n// Context interface\ninterface TimetableContextType {\n  state: TimetableState;\n  // Event management\n  loadEvents: () => Promise<void>;\n  addEvent: (event: Omit<TimetableEvent, 'id'>) => Promise<ValidationResult>;\n  updateEvent: (event: TimetableEvent) => Promise<ValidationResult>;\n  deleteEvent: (eventId: string) => Promise<void>;\n  // Recurring event management\n  addRecurringEvent: (event: Omit<TimetableEvent, 'id'>, pattern: RecurrencePattern) => Promise<ValidationResult>;\n  updateRecurringEvent: (event: TimetableEvent, pattern?: RecurrencePattern) => Promise<ValidationResult>;\n  deleteRecurringEvent: (eventId: string) => Promise<void>;\n  // Date management\n  setSelectedDate: (date: Date) => void;\n  setViewMode: (mode: 'day' | 'week' | 'month') => void;\n  getEventsForSelectedDate: () => TimetableEvent[];\n  getEventsForDate: (date: Date) => TimetableEvent[];\n  getEventsInRange: (startDate: Date, endDate: Date) => TimetableEvent[];\n  // Historical data\n  getCompletedEventsForDate: (date: Date) => TimetableEvent[];\n  getEventHistory: (eventId: string) => TimetableEvent[];\n  // Conflict management\n  checkEventConflicts: (event: TimetableEvent) => TimetableEvent[];\n  validateAndCheckConflicts: (event: Partial<TimetableEvent>) => ValidationResult;\n  clearConflicts: () => void;\n  // Utility functions\n  getTotalScheduledTimeForDate: (date: Date) => number;\n  getAvailableSlots: (date: Date, duration?: number) => { start: Date; end: Date }[];\n}\n\n// Create context\nconst TimetableContext = createContext<TimetableContextType | undefined>(undefined);\n\n// Provider component\ninterface TimetableProviderProps {\n  children: ReactNode;\n}\n\nexport const TimetableProvider: React.FC<TimetableProviderProps> = ({ children }) => {\n  const [state, dispatch] = useReducer(timetableReducer, initialState);\n  const { currentDate } = useDateNavigation();\n  const { getEventsForDate, getEventsInRange } = useRecurringEvents();\n\n  // Sync selected date with date navigation service\n  useEffect(() => {\n    dispatch({ type: 'SET_SELECTED_DATE', payload: currentDate });\n  }, [currentDate]);\n\n  // Load events on mount\n  useEffect(() => {\n    loadEvents();\n  }, []);\n\n  // Event management functions\n  const loadEvents = async (): Promise<void> => {\n    try {\n      dispatch({ type: 'SET_LOADING', payload: true });\n      const events = await loadTimetableEvents();\n      dispatch({ type: 'SET_EVENTS', payload: events });\n    } catch (error) {\n      dispatch({ type: 'SET_ERROR', payload: 'Failed to load events' });\n      console.error('Error loading events:', error);\n    }\n  };\n\n  const addEvent = async (eventData: Omit<TimetableEvent, 'id'>): Promise<ValidationResult> => {\n    try {\n      // Validate event data\n      const validation = validateTimetableEvent(eventData);\n      if (!validation.isValid) {\n        return validation;\n      }\n\n      // Create event with ID\n      const newEvent: TimetableEvent = {\n        ...eventData,\n        id: generateId(),\n      };\n\n      // Check for conflicts\n      const conflicts = findConflictingEvents(newEvent, state.events);\n      if (conflicts.length > 0) {\n        dispatch({ type: 'SET_CONFLICTS', payload: conflicts });\n        return {\n          isValid: false,\n          errors: [`Event conflicts with ${conflicts.length} existing event(s)`],\n        };\n      }\n\n      // Save to storage\n      await addEventToStorage(newEvent);\n      \n      // Update state\n      dispatch({ type: 'ADD_EVENT', payload: newEvent });\n      dispatch({ type: 'CLEAR_CONFLICTS' });\n\n      return { isValid: true, errors: [] };\n    } catch (error) {\n      const errorMessage = 'Failed to add event';\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      console.error('Error adding event:', error);\n      return { isValid: false, errors: [errorMessage] };\n    }\n  };\n\n  const updateEvent = async (updatedEvent: TimetableEvent): Promise<ValidationResult> => {\n    try {\n      // Validate event data\n      const validation = validateTimetableEvent(updatedEvent);\n      if (!validation.isValid) {\n        return validation;\n      }\n\n      // Check for conflicts (excluding the event being updated)\n      const otherEvents = state.events.filter(event => event.id !== updatedEvent.id);\n      const conflicts = findConflictingEvents(updatedEvent, otherEvents);\n      if (conflicts.length > 0) {\n        dispatch({ type: 'SET_CONFLICTS', payload: conflicts });\n        return {\n          isValid: false,\n          errors: [`Event conflicts with ${conflicts.length} existing event(s)`],\n        };\n      }\n\n      // Save to storage\n      await updateEventInStorage(updatedEvent);\n      \n      // Update state\n      dispatch({ type: 'UPDATE_EVENT', payload: updatedEvent });\n      dispatch({ type: 'CLEAR_CONFLICTS' });\n\n      return { isValid: true, errors: [] };\n    } catch (error) {\n      const errorMessage = 'Failed to update event';\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      console.error('Error updating event:', error);\n      return { isValid: false, errors: [errorMessage] };\n    }\n  };\n\n  const deleteEvent = async (eventId: string): Promise<void> => {\n    try {\n      await deleteEventFromStorage(eventId);\n      dispatch({ type: 'DELETE_EVENT', payload: eventId });\n    } catch (error) {\n      dispatch({ type: 'SET_ERROR', payload: 'Failed to delete event' });\n      console.error('Error deleting event:', error);\n    }\n  };\n\n  // Recurring event management functions\n  const addRecurringEvent = async (eventData: Omit<TimetableEvent, 'id'>, pattern: RecurrencePattern): Promise<ValidationResult> => {\n    try {\n      // Validate event data\n      const validation = validateTimetableEvent(eventData);\n      if (!validation.isValid) {\n        return validation;\n      }\n\n      // Create recurring event with ID\n      const newEvent: TimetableEvent = {\n        ...eventData,\n        id: generateId(),\n        isRecurring: true,\n        recurrencePattern: pattern,\n      };\n\n      // Save to storage\n      await addEventToStorage(newEvent);\n      \n      // Update state (add to recurring events)\n      dispatch({ type: 'SET_RECURRING_EVENTS', payload: [...state.recurringEvents, newEvent] });\n      dispatch({ type: 'CLEAR_CONFLICTS' });\n\n      return { isValid: true, errors: [] };\n    } catch (error) {\n      const errorMessage = 'Failed to add recurring event';\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      console.error('Error adding recurring event:', error);\n      return { isValid: false, errors: [errorMessage] };\n    }\n  };\n\n  const updateRecurringEvent = async (updatedEvent: TimetableEvent, pattern?: RecurrencePattern): Promise<ValidationResult> => {\n    try {\n      // Validate event data\n      const validation = validateTimetableEvent(updatedEvent);\n      if (!validation.isValid) {\n        return validation;\n      }\n\n      // Update pattern if provided\n      if (pattern) {\n        updatedEvent.recurrencePattern = pattern;\n      }\n\n      // Save to storage\n      await updateEventInStorage(updatedEvent);\n      \n      // Update state\n      if (updatedEvent.isRecurring) {\n        dispatch({ \n          type: 'SET_RECURRING_EVENTS', \n          payload: state.recurringEvents.map(event =>\n            event.id === updatedEvent.id ? updatedEvent : event\n          )\n        });\n      } else {\n        dispatch({ type: 'UPDATE_EVENT', payload: updatedEvent });\n      }\n      dispatch({ type: 'CLEAR_CONFLICTS' });\n\n      return { isValid: true, errors: [] };\n    } catch (error) {\n      const errorMessage = 'Failed to update recurring event';\n      dispatch({ type: 'SET_ERROR', payload: errorMessage });\n      console.error('Error updating recurring event:', error);\n      return { isValid: false, errors: [errorMessage] };\n    }\n  };\n\n  const deleteRecurringEvent = async (eventId: string): Promise<void> => {\n    try {\n      await deleteEventFromStorage(eventId);\n      dispatch({ \n        type: 'SET_RECURRING_EVENTS', \n        payload: state.recurringEvents.filter(event => event.id !== eventId)\n      });\n    } catch (error) {\n      dispatch({ type: 'SET_ERROR', payload: 'Failed to delete recurring event' });\n      console.error('Error deleting recurring event:', error);\n    }\n  };\n\n  // Date management functions\n  const setSelectedDate = (date: Date): void => {\n    dispatch({ type: 'SET_SELECTED_DATE', payload: date });\n    dispatch({ type: 'CLEAR_CONFLICTS' });\n  };\n\n  const setViewMode = (mode: 'day' | 'week' | 'month'): void => {\n    dispatch({ type: 'SET_VIEW_MODE', payload: mode });\n  };\n\n  const getEventsForSelectedDate = (): TimetableEvent[] => {\n    return getEventsForDate(state.events, state.recurringEvents, state.selectedDate);\n  };\n\n  const getEventsForDateUtil = (date: Date): TimetableEvent[] => {\n    return getEventsForDate(state.events, state.recurringEvents, date);\n  };\n\n  const getEventsInRangeUtil = (startDate: Date, endDate: Date): TimetableEvent[] => {\n    return getEventsInRange(state.events, state.recurringEvents, startDate, endDate);\n  };\n\n  // Historical data functions\n  const getCompletedEventsForDate = (date: Date): TimetableEvent[] => {\n    const allEvents = getEventsForDate(state.events, state.recurringEvents, date);\n    return allEvents.filter(event => event.isCompleted);\n  };\n\n  const getEventHistory = (eventId: string): TimetableEvent[] => {\n    // For recurring events, this would return all instances\n    // For now, return the base event\n    const event = state.events.find(e => e.id === eventId) || \n                  state.recurringEvents.find(e => e.id === eventId);\n    return event ? [event] : [];\n  };\n\n  // Conflict management functions\n  const checkEventConflicts = (event: TimetableEvent): TimetableEvent[] => {\n    const conflicts = findConflictingEvents(event, state.events);\n    dispatch({ type: 'SET_CONFLICTS', payload: conflicts });\n    return conflicts;\n  };\n\n  const validateAndCheckConflicts = (eventData: Partial<TimetableEvent>): ValidationResult => {\n    // First validate the event data\n    const validation = validateTimetableEvent(eventData);\n    if (!validation.isValid) {\n      return validation;\n    }\n\n    // Then check for conflicts if it's a complete event\n    if (eventData.id && eventData.startTime && eventData.duration) {\n      const event = eventData as TimetableEvent;\n      const conflicts = checkEventConflicts(event);\n      \n      if (conflicts.length > 0) {\n        return {\n          isValid: false,\n          errors: [`Event conflicts with ${conflicts.length} existing event(s)`],\n        };\n      }\n    }\n\n    return { isValid: true, errors: [] };\n  };\n\n  const clearConflicts = (): void => {\n    dispatch({ type: 'CLEAR_CONFLICTS' });\n  };\n\n  // Utility functions\n  const getTotalScheduledTimeForDate = (date: Date): number => {\n    const dayEvents = getEventsForDate(state.events, date);\n    return dayEvents.reduce((total, event) => total + event.duration, 0);\n  };\n\n  const getAvailableSlots = (date: Date, duration: number = 60): { start: Date; end: Date }[] => {\n    // This is a simplified version - you might want to import from dateUtils\n    const dayEvents = getEventsForDate(state.events, date);\n    const workingHours = { start: '09:00', end: '17:00' };\n    \n    // For now, return a basic implementation\n    // In a real app, you'd use the getAvailableTimeSlots from dateUtils\n    const slots: { start: Date; end: Date }[] = [];\n    \n    const [startHour, startMinute] = workingHours.start.split(':').map(Number);\n    const workStart = new Date(date);\n    workStart.setHours(startHour, startMinute, 0, 0);\n    \n    const [endHour, endMinute] = workingHours.end.split(':').map(Number);\n    const workEnd = new Date(date);\n    workEnd.setHours(endHour, endMinute, 0, 0);\n    \n    if (dayEvents.length === 0) {\n      slots.push({ start: workStart, end: workEnd });\n    }\n    \n    return slots;\n  };\n\n  // Context value\n  const contextValue: TimetableContextType = {\n    state,\n    loadEvents,\n    addEvent,\n    updateEvent,\n    deleteEvent,\n    addRecurringEvent,\n    updateRecurringEvent,\n    deleteRecurringEvent,\n    setSelectedDate,\n    setViewMode,\n    getEventsForSelectedDate,\n    getEventsForDate: getEventsForDateUtil,\n    getEventsInRange: getEventsInRangeUtil,\n    getCompletedEventsForDate,\n    getEventHistory,\n    checkEventConflicts,\n    validateAndCheckConflicts,\n    clearConflicts,\n    getTotalScheduledTimeForDate,\n    getAvailableSlots,\n  };\n\n  return (\n    <TimetableContext.Provider value={contextValue}>\n      {children}\n    </TimetableContext.Provider>\n  );\n};\n\n// Custom hook to use the context\nexport const useTimetable = (): TimetableContextType => {\n  const context = useContext(TimetableContext);\n  if (context === undefined) {\n    throw new Error('useTimetable must be used within a TimetableProvider');\n  }\n  return context;\n};\n\nexport default TimetableContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}